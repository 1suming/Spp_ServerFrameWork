---- str Matches (1485 in 75 files) ----
App_combo_protocol.cpp (libprotocol\src):        m_ComboRsp.push_back(std::make_pair<string, unsigned int>(string(pRsp,len), cmd));
App_combo_protocol.cpp (libprotocol\src):    string & rsp = t.first;
App_combo_protocol.cpp (libprotocol\src):int AppComboRsp::GetSubRsp(string& subpack,unsigned short idx)
App_combo_protocol.h (libprotocol\include):#include <string>
App_combo_protocol.h (libprotocol\include):using std::string;
App_combo_protocol.h (libprotocol\include):   int MakeReq(string &req)
App_combo_protocol.h (libprotocol\include):        m_ComboReq.push_back(std::make_pair<string,uint64_t>(string(p,len),val));
App_combo_protocol.h (libprotocol\include):    void Add(unsigned int server_type,unsigned int route_key,const string & pk)
App_combo_protocol.h (libprotocol\include):        m_ComboReq.push_back(std::make_pair<string,uint64_t>(pk,val));
App_combo_protocol.h (libprotocol\include):    string &Cookie(){return m_Cookie;}
App_combo_protocol.h (libprotocol\include):            string & req = m_ComboReq[i].first;
App_combo_protocol.h (libprotocol\include):    string m_Cookie;//Combo自身Cookie
App_combo_protocol.h (libprotocol\include):    typedef std::pair<string,uint64_t> item_type;
App_combo_protocol.h (libprotocol\include):    string &Cookie(){return m_Cookie;}
App_combo_protocol.h (libprotocol\include):    int GetSubRsp(string& subpack,unsigned short idx);
App_combo_protocol.h (libprotocol\include):    string m_Cookie;//Combo cookie信息
App_combo_protocol.h (libprotocol\include):    typedef std::pair<string, unsigned int> item_type;
Atomic.h (libcomm\include\asm):typedef struct {
Atomic.h (libcomm\include\asm):typedef struct { 
Base64.cpp (libcomm\src\util):#include <string.h>
Base64.cpp (libcomm\src\util):void base64_encode(const char *src, int src_len, std::string &dst)
Base64.cpp (libcomm\src\util):void base64_decode(const char *src, int src_len, std::string &dst)
Base64.h (libcomm\include):#include <string>
Base64.h (libcomm\include):void base64_encode(const char *src, int src_len, std::string &dst);
Base64.h (libcomm\include):void base64_decode(const char *src, int src_len, std::string &dst);
Base64.h (libcomm\include):inline void base64_encode(const std::string &src, std::string &dst)
Base64.h (libcomm\include):    base64_encode(src.c_str(), src.size(), dst);
Base64.h (libcomm\include):inline void base64_decode(const std::string &src, std::string &dst)
Base64.h (libcomm\include):    base64_decode(src.c_str(), src.size(), dst);
Base_socket.cpp (libcomm\src\sockcommu):#include <string.h>
Base_socket.cpp (libcomm\src\sockcommu):inline int DiffMillSec(const struct timeval &t1, const struct timeval &t2)
Base_socket.cpp (libcomm\src\sockcommu):inline int DiffMillSec(const struct timeval &t)
Base_socket.cpp (libcomm\src\sockcommu):    struct timeval tv;
Base_socket.cpp (libcomm\src\sockcommu):    struct timezone tz;
Base_socket.cpp (libcomm\src\sockcommu):inline void MkTimeval(struct timeval &tv, int millisec)
Base_socket.cpp (libcomm\src\sockcommu):		int nSocketType:SOCKET类型（SOCK_DGRAM:UDP,SOCK_STREAM:TCP)
Base_socket.cpp (libcomm\src\sockcommu):    if( (m_iType != SOCK_STREAM) && (m_iType != SOCK_DGRAM))
Base_socket.cpp (libcomm\src\sockcommu):    int n =  getpeername(m_iSocket, (struct sockaddr *)&m_PeerAddr, &len);
Base_socket.cpp (libcomm\src\sockcommu):    int n =  getsockname(m_iSocket, (struct sockaddr *)&m_SockAddr, &len);
Base_socket.cpp (libcomm\src\sockcommu):    struct sockaddr_in inaddr;	
Base_socket.cpp (libcomm\src\sockcommu):    bzero (&inaddr, sizeof (struct sockaddr_in));
Base_socket.cpp (libcomm\src\sockcommu):    if(pszBindIP== 0 || pszBindIP[0] == 0 || strcmp(pszBindIP, "0.0.0.0") == 0)
Base_socket.cpp (libcomm\src\sockcommu):    int n = bind(m_iSocket, (struct sockaddr*)&inaddr, sizeof(struct sockaddr));
Base_socket.cpp (libcomm\src\sockcommu):		struct sockaddr *name：返回的本端地址
Base_socket.cpp (libcomm\src\sockcommu):int CBaseSocket::GetSockName(struct sockaddr *name, socklen_t *namelen)
Base_socket.cpp (libcomm\src\sockcommu):		struct sockaddr *name：返回的本端地址
Base_socket.cpp (libcomm\src\sockcommu):int CBaseSocket::GetPeerName(struct sockaddr *name, socklen_t *namelen)
Base_socket.cpp (libcomm\src\sockcommu):    if(m_iType == SOCK_STREAM)
Base_socket.cpp (libcomm\src\sockcommu):    struct timeval tv;
Base_socket.cpp (libcomm\src\sockcommu):    struct timeval*ptv = &tv;
Base_socket.cpp (libcomm\src\sockcommu):    struct timeval tv;
Base_socket.cpp (libcomm\src\sockcommu):    struct timeval*ptv = &tv;
Base_socket.cpp (libcomm\src\sockcommu):    struct timeval tv;
Base_socket.cpp (libcomm\src\sockcommu):    struct timeval *ptv = &tv;
Base_socket.cpp (libcomm\src\sockcommu):    struct timeval start;
Base_socket.cpp (libcomm\src\sockcommu):    struct timezone tz;
Base_socket.cpp (libcomm\src\sockcommu):    struct timeval start;
Base_socket.cpp (libcomm\src\sockcommu):    struct timezone tz;
Base_socket.cpp (libcomm\src\sockcommu):    struct timeval start;
Base_socket.cpp (libcomm\src\sockcommu):    struct timezone tz;
Base_socket.cpp (libcomm\src\sockcommu):int CBaseSocket::Connect(struct sockaddr_in *addr, int timeout_usec /*=-1*/)
Base_socket.cpp (libcomm\src\sockcommu):    socklen_t addr_len = sizeof(struct sockaddr_in);
Base_socket.cpp (libcomm\src\sockcommu):        int n = connect(m_iSocket, (struct sockaddr *)addr, addr_len);
Base_socket.cpp (libcomm\src\sockcommu):    retval= connect(m_iSocket, (struct sockaddr *) addr, addr_len);
Base_socket.cpp (libcomm\src\sockcommu):    struct timeval timeout;
Base_socket.cpp (libcomm\src\sockcommu):    struct sockaddr_in addr;
Base_socket.cpp (libcomm\src\sockcommu):	strcpy(req + 1,"12345");
Base_socket.h (libcomm\include):#include <sys/stropts.h>
Base_socket.h (libcomm\include):#include <string.h>
Base_socket.h (libcomm\include):#include <string>
Base_socket.h (libcomm\include):using std::string;
Base_socket.h (libcomm\include):    static char *inet_ntoa_r(struct in_addr in, char *buf)
Base_socket.h (libcomm\include):        return strerror(errno);
Base_socket.h (libcomm\include):    int CreateTcp(){return Create(SOCK_STREAM);}
Base_socket.h (libcomm\include):    		struct sockaddr *name：返回的本端地址
Base_socket.h (libcomm\include):    int GetSockName(struct sockaddr *name, socklen_t *namelen);
Base_socket.h (libcomm\include):    		sring &strHost：返回的本端IP地址
Base_socket.h (libcomm\include):    int GetSockIP(string &strHost)
Base_socket.h (libcomm\include):        strHost = inet_ntoa_r(m_SockAddr.sin_addr, buf);
Base_socket.h (libcomm\include):        string s;
Base_socket.h (libcomm\include):        strncpy(ip, s.c_str(), len);
Base_socket.h (libcomm\include):    		struct sockaddr *name：返回的本端地址
Base_socket.h (libcomm\include):    int GetPeerName(struct sockaddr *name, socklen_t *namelen);
Base_socket.h (libcomm\include):    		sring &strHost：返回的对端IP地址
Base_socket.h (libcomm\include):    int GetPeerIP(string &strHost)
Base_socket.h (libcomm\include):        strHost = inet_ntoa_r(m_PeerAddr.sin_addr, buf);
Base_socket.h (libcomm\include):        string s;
Base_socket.h (libcomm\include):        strncpy(ip, s.c_str(), len);
Base_socket.h (libcomm\include):        int nSocketType:SOCKET类型（SOCK_DGRAM:UDP,SOCK_STREAM:TCP)
Base_socket.h (libcomm\include):    int Connect(struct sockaddr_in *addr, int timeout_usec =-1);
Base_socket.h (libcomm\include):    *   const struct sockaddr *serv_addr:服务器地址
Base_socket.h (libcomm\include):    string m_strPeerAddr;//对端地址 
Base_socket.h (libcomm\include):    struct sockaddr_in m_SockAddr;	//本端地址
Base_socket.h (libcomm\include):    struct sockaddr_in m_PeerAddr;	//对端地址
Base_socket.h (libcomm\include):            int bytes = sendto(m_iSocket, pBuffer, nBytes,iFlags, (struct sockaddr *) &m_PeerAddr, addr_len );
Base_socket.h (libcomm\include):            int bytes =::recvfrom(m_iSocket, pBuffer, nBytes, iFlags, (struct sockaddr *) &m_PeerAddr, &addr_len ) ;
Base_socket.h (libcomm\include):        struct sockaddr *pFromAddr:对方的地址 
Base_socket.h (libcomm\include):    int Recvfrom(void *pBuffer, unsigned int nBytes, struct sockaddr *pFromAddr, socklen_t* iAddrLen, int iFlags /*= 0*/)
Base_socket.h (libcomm\include):        struct sockaddr *pFromAddr:对方的地址 
Base_socket.h (libcomm\include):    int Sendto(void *pBuffer, unsigned int nBytes, struct sockaddr *pToAddr, socklen_t iAddrLen,int iFlags /*= 0*/ )
Base_socket.h (libcomm\include):        Attach(fd, SOCK_STREAM);
Benchadapter.cpp (serverframework\src\base):#include <string.h>
Benchadapter.cpp (serverframework\src\base):    string strMsg = pack.GetPack(header);
Benchadapter.cpp (serverframework\src\base):    memcpy(blob->data,strMsg.data(),strMsg.size());
Benchadapter.cpp (serverframework\src\base):    blob->len = strMsg.size();
Benchapi.h (serverframework\include):extern char* config_get_strval (const char* key);
Benchapi.h (serverframework\include):extern int safe_socket_listen (struct sockaddr_in *servaddr, int type);
Benchapi.h (serverframework\include):extern int safe_tcp_accept (int sockfd, struct sockaddr_in *peer);
Benchapiplus.h (serverframework\include):typedef struct 
Cache.cpp (serverframework\src\base):#include <string.h>
ChunkAlloc.hpp (libcomm\include):#include <string.h>
ChunkAlloc.hpp (libcomm\include):typedef struct tagTChunkNode
ChunkAlloc.hpp (libcomm\include):typedef struct tagTChunk
Commu.h (serverframework\include):#include <string.h>
Commu.h (serverframework\include):typedef struct tagBlobType
Commu.h (serverframework\include):typedef struct
Commu.h (serverframework\include):    int type_;					//fd type (SOCK_STREAM\SOCK_DGRAM\...)
Commumng.h (serverframework\include):#include <string>
Data_platform_protocol.cpp (libprotocol\src):     case TLV_STRING:
Data_platform_protocol.cpp (libprotocol\src):        pk.PackBinary((const void *)(tlv.string_value.data()), tlv.string_value.size());
Data_platform_protocol.cpp (libprotocol\src):     case TLV_STRING:
Data_platform_protocol.cpp (libprotocol\src):        upk.UnPackBinary(tlv.string_value, tlv.length);
Data_platform_protocol.cpp (libprotocol\src):     case TLV_STRING:
Data_platform_protocol.cpp (libprotocol\src):        pk.PackBinary((const void *)(tlv.string_value.data()), tlv.string_value.size());
Data_platform_protocol.cpp (libprotocol\src):int DataPlatformProtocol::SetRouteKey(string &pack, unsigned int key, bool unique)
Data_platform_protocol.cpp (libprotocol\src):int DataPlatformProtocol::MakeQueryReq(string &pack, bool is_primary_key, const ConditionExpression &cond, 
Data_platform_protocol.cpp (libprotocol\src):int DataPlatformProtocol::MakeQueryReq(string &pack,bool is_primary_key, const ConditionExpression &cond, 
Data_platform_protocol.cpp (libprotocol\src):int DataPlatformProtocol::MakeQueryReq(string &pack, bool is_primary_key, 
Data_platform_protocol.cpp (libprotocol\src):int DataPlatformProtocol::MakeQueryReq(string &pack, bool is_primary_key, 
Data_platform_protocol.cpp (libprotocol\src):        logic_exp_len = strlen(logic_expression);
Data_platform_protocol.cpp (libprotocol\src):    string cookie;
Data_platform_protocol.cpp (libprotocol\src):int DataPlatformProtocol::ParseQueryRsp(string &cookie, unsigned short &status, std::vector<unsigned int> &fields,
Data_platform_protocol.cpp (libprotocol\src):int DataPlatformProtocol::MakeCountReq(string &pack, 
Data_platform_protocol.cpp (libprotocol\src):int DataPlatformProtocol::MakeCountReq(string &pack, 
Data_platform_protocol.cpp (libprotocol\src):        logic_exp_len = strlen(logic_expression);
Data_platform_protocol.cpp (libprotocol\src):    string cookie;
Data_platform_protocol.cpp (libprotocol\src):int DataPlatformProtocol::ParseCountRsp(string &cookie, unsigned short &status, unsigned int &record_num, 
Data_platform_protocol.cpp (libprotocol\src):int DataPlatformProtocol::MakeDeleteReq(string &pack, bool is_async,
Data_platform_protocol.cpp (libprotocol\src):int DataPlatformProtocol::MakeDeleteReq(string &pack, bool is_async,
Data_platform_protocol.cpp (libprotocol\src):    string cookie;
Data_platform_protocol.cpp (libprotocol\src):int DataPlatformProtocol::ParseDeleteRsp(string &cookie, unsigned short &status, unsigned int &record_num, 
Data_platform_protocol.cpp (libprotocol\src):int DataPlatformProtocol::MakeUpdateReq(string &pack,  bool is_async,
Data_platform_protocol.cpp (libprotocol\src):int DataPlatformProtocol::MakeUpdateReq(string &pack, bool is_async,
Data_platform_protocol.cpp (libprotocol\src):    string cookie;
Data_platform_protocol.cpp (libprotocol\src):int DataPlatformProtocol::ParseUpdateRsp(string &cookie, unsigned short &status, unsigned int &record_num, 
Data_platform_protocol.cpp (libprotocol\src):int DataPlatformProtocol::MakeInsertReq(string &pack, bool is_async,
Data_platform_protocol.cpp (libprotocol\src):int DataPlatformProtocol::MakeInsertReq(string &pack, bool is_async,
Data_platform_protocol.cpp (libprotocol\src):    string cookie;
Data_platform_protocol.cpp (libprotocol\src):int DataPlatformProtocol::ParseInsertRsp(string &cookie, unsigned short &status, unsigned int &record_num, 
Data_platform_protocol.cpp (libprotocol\src):int CommCookie::Pack(string &ck) 
Data_platform_protocol.cpp (libprotocol\src):    int ck_len =  8 + m_strExtInfo.size() + m_ReqPackLen;
Data_platform_protocol.cpp (libprotocol\src):    unsigned int ck_len =  8 + m_strExtInfo.size() + m_ReqPackLen;
Data_platform_protocol.cpp (libprotocol\src):    *p2 = htons(m_strExtInfo.size());
Data_platform_protocol.cpp (libprotocol\src):    if(m_strExtInfo.size() > 0)
Data_platform_protocol.cpp (libprotocol\src):        memcpy(p, m_strExtInfo.data(), m_strExtInfo.size());
Data_platform_protocol.cpp (libprotocol\src):    p+= m_strExtInfo.size();
Data_platform_protocol.cpp (libprotocol\src):        m_strExtInfo.assign(pBuf, other_size);
Data_platform_protocol.cpp (libprotocol\src):int DpQueryReq::MakeReq(string &req)
Data_platform_protocol.cpp (libprotocol\src):int DpUpdateReq::MakeReq(string &req)
Data_platform_protocol.cpp (libprotocol\src):int DpInsertReq::MakeReq(string &req)
Data_platform_protocol.cpp (libprotocol\src):int DpDeleteReq::MakeReq(string &req)
Data_platform_protocol.cpp (libprotocol\src):int DpCountReq::MakeReq(string &req)
Data_platform_protocol.cpp (libprotocol\src):int DpCondFindReq::MakeReq(string & req)
Data_platform_protocol.cpp (libprotocol\src):    string req;
Data_platform_protocol.h (libprotocol\include):#include <string>
Data_platform_protocol.h (libprotocol\include):using std::string;
Data_platform_protocol.h (libprotocol\include):5：string，变长
Data_platform_protocol.h (libprotocol\include):const unsigned char TLV_STRING = 5;
Data_platform_protocol.h (libprotocol\include):    string string_value; //字符串值或二进制值
Data_platform_protocol.h (libprotocol\include):    TLV(const string& v){Assign(v);}
Data_platform_protocol.h (libprotocol\include):        if( (r.type == TLV_STRING) || (r.type == TLV_BINARY))
Data_platform_protocol.h (libprotocol\include):                this->string_value = r.string_value;
Data_platform_protocol.h (libprotocol\include):    void Assign(const string &v){type = TLV_STRING; length = v.size(); string_value = v;}
Data_platform_protocol.h (libprotocol\include):        type = TLV_STRING; 
Data_platform_protocol.h (libprotocol\include):            length = strlen(v); 
Data_platform_protocol.h (libprotocol\include):            string_value = v;
Data_platform_protocol.h (libprotocol\include):            string_value.assign((const char *)v, len);
Data_platform_protocol.h (libprotocol\include):    static int SetRouteKey(string &pack, unsigned int key, bool unique=true);
Data_platform_protocol.h (libprotocol\include):    static int MakeQueryReq(string &pack,bool is_primary_key, const ConditionExpression &cond, 
Data_platform_protocol.h (libprotocol\include):    static int MakeQueryReq(string &pack,bool is_primary_key, const ConditionExpression &cond, 
Data_platform_protocol.h (libprotocol\include):    static int MakeQueryReq(string &pack, bool is_primary_key, 
Data_platform_protocol.h (libprotocol\include):    static int MakeQueryReq(string &pack, bool is_primary_key, 
Data_platform_protocol.h (libprotocol\include):    static int ParseQueryRsp(string &cookie, unsigned short &status, std::vector<unsigned int> &fileds,
Data_platform_protocol.h (libprotocol\include):    static int MakeCountReq(string &pack, 
Data_platform_protocol.h (libprotocol\include):    static int MakeCountReq(string &pack, 
Data_platform_protocol.h (libprotocol\include):    static int ParseCountRsp(string &cookie, unsigned short &status, unsigned int &record_num, 
Data_platform_protocol.h (libprotocol\include):    static int MakeDeleteReq(string &pack, bool is_async,
Data_platform_protocol.h (libprotocol\include):    static int MakeDeleteReq(string &pack, bool is_async,
Data_platform_protocol.h (libprotocol\include):    static int ParseDeleteRsp(string &cookie, unsigned short &status, unsigned int &record_num, 
Data_platform_protocol.h (libprotocol\include):    static int MakeUpdateReq(string &pack, bool is_async,
Data_platform_protocol.h (libprotocol\include):    static int MakeUpdateReq(string &pack, bool is_async,
Data_platform_protocol.h (libprotocol\include):    static int ParseUpdateRsp(string &cookie, unsigned short &status, unsigned int &record_num, 
Data_platform_protocol.h (libprotocol\include):    static int MakeInsertReq(string &pack, bool is_async,
Data_platform_protocol.h (libprotocol\include):    static int MakeInsertReq(string &pack, bool is_async,
Data_platform_protocol.h (libprotocol\include):    static int ParseInsertRsp(string &cookie, unsigned short &status, unsigned int &record_num, 
Data_platform_protocol.h (libprotocol\include):       virtual int Pack(string &cookie) = 0;
Data_platform_protocol.h (libprotocol\include):                                        const string &extInfo) : m_Source(source), m_Flow(flow),
Data_platform_protocol.h (libprotocol\include):                                        m_strExtInfo(extInfo){}
Data_platform_protocol.h (libprotocol\include):       virtual int Pack(string &cookie) ;
Data_platform_protocol.h (libprotocol\include):       virtual int UnPack(const string & ck){return UnPack(ck.data(), ck.size());}    
Data_platform_protocol.h (libprotocol\include):       string m_strExtInfo;         //业务自定的扩展数据。可以为空
Data_platform_protocol.h (libprotocol\include):       virtual int MakeReq(string &req)=0;
Data_platform_protocol.h (libprotocol\include):       void SetRouteKey(const string &rk, bool isUnique)
Data_platform_protocol.h (libprotocol\include):            return SetRouteKey(rk.c_str(),isUnique);
Data_platform_protocol.h (libprotocol\include):        static unsigned int MakeRouteKey(const string &rk){return MakeRouteKey(rk.c_str());}    
Data_platform_protocol.h (libprotocol\include):      string &Cookie(){return m_Cookie;}
Data_platform_protocol.h (libprotocol\include):        string m_Cookie;
Data_platform_protocol.h (libprotocol\include):      string &Cookie(){return m_Cookie;}
Data_platform_protocol.h (libprotocol\include):        string m_Cookie;
Data_platform_protocol.h (libprotocol\include):   virtual int MakeReq(string &req);
Data_platform_protocol.h (libprotocol\include):    string m_LogicExp;
Data_platform_protocol.h (libprotocol\include):   virtual int MakeReq(string &req);
Data_platform_protocol.h (libprotocol\include):    string m_LogicExp;
Data_platform_protocol.h (libprotocol\include):       virtual int MakeReq(string &req);
Data_platform_protocol.h (libprotocol\include):       virtual int MakeReq(string &req);
Data_platform_protocol.h (libprotocol\include):    string m_LogicExp;
Data_platform_protocol.h (libprotocol\include):       virtual int MakeReq(string &req);
Data_platform_protocol.h (libprotocol\include):    string m_LogicExp;
Data_platform_protocol.h (libprotocol\include):   virtual int MakeReq(string &req)
Data_platform_protocol.h (libprotocol\include):            string req;
Data_platform_protocol.h (libprotocol\include):   virtual int MakeReq(string &req);
Data_platform_protocol.h (libprotocol\include):        string pack;
Defaultctrl.cpp (serverframework\src\controller):#include <string.h>
Defaultctrl.cpp (serverframework\src\controller): #include <string>
Defaultctrl.cpp (serverframework\src\controller):static int CvtTime(int & hour,int & minute,int & second,const string & strTime)
Defaultctrl.cpp (serverframework\src\controller):    string::size_type first = strTime.find(':');
Defaultctrl.cpp (serverframework\src\controller):    string::size_type last = strTime.find(':',first + 1);
Defaultctrl.cpp (serverframework\src\controller):    if(first == string::npos  || last == string::npos )
Defaultctrl.cpp (serverframework\src\controller):    string strHour = strTime.substr(0,first);
Defaultctrl.cpp (serverframework\src\controller):    string strMinute = strTime.substr(first + 1,last);
Defaultctrl.cpp (serverframework\src\controller):    string strSecond = strTime.substr(last + 1);
Defaultctrl.cpp (serverframework\src\controller):    hour = atoi(strHour.c_str());
Defaultctrl.cpp (serverframework\src\controller):    minute = atoi(strMinute.c_str());
Defaultctrl.cpp (serverframework\src\controller):    second = atoi(strSecond.c_str());
Defaultctrl.cpp (serverframework\src\controller):struct CServerBase::TInternal
Defaultctrl.cpp (serverframework\src\controller):            if(stat_output_file_.c_str() != "" )
Defaultctrl.cpp (serverframework\src\controller):                WriteStatResult(stat_output_file_.c_str(),pstatbuff,bufflen);
Defaultctrl.cpp (serverframework\src\controller):            struct tm cur_tm;
Defaultctrl.cpp (serverframework\src\controller):            struct tm pre_tm;
Defaultctrl.cpp (serverframework\src\controller):    int group_num = atoi( conf.GetAttrib("groupnum").c_str() ); //spp_ctrl.xml
Defaultctrl.cpp (serverframework\src\controller):    int check_group_interval = atoi(conf.GetAttrib("check_group_interval").c_str() );
Defaultctrl.cpp (serverframework\src\controller):    	start_grp = atoi(conf.GetChildAttrib("start_group").c_str());
Defaultctrl.cpp (serverframework\src\controller):    	end_grp = atoi(conf.GetChildAttrib("end_group").c_str());
Defaultctrl.cpp (serverframework\src\controller):    	strncpy(groupinfo.basepath_, conf.GetChildAttrib("basepath").c_str(), MAX_FILEPATH_LEN);
Defaultctrl.cpp (serverframework\src\controller):    	strncpy(groupinfo.exefile_, conf.GetChildAttrib("exe").c_str(), MAX_FILEPATH_LEN);
Defaultctrl.cpp (serverframework\src\controller):    	strncpy(groupinfo.etcfile_, conf.GetChildAttrib("etc").c_str(), MAX_FILEPATH_LEN);
Defaultctrl.cpp (serverframework\src\controller):    	strncpy(groupinfo.server_flag_,conf.GetChildAttrib("flag").c_str(),MAX_SERVER_FLAG_LEN);
Defaultctrl.cpp (serverframework\src\controller):    	groupinfo.exitsignal_ = atoi(conf.GetChildAttrib("exitsignal").c_str());
Defaultctrl.cpp (serverframework\src\controller):    	if(*conf.GetChildAttrib("maxprocnum").c_str())
Defaultctrl.cpp (serverframework\src\controller):            groupinfo.maxprocnum_ = atoi(conf.GetChildAttrib("maxprocnum").c_str());
Defaultctrl.cpp (serverframework\src\controller):    	if(*conf.GetChildAttrib("minprocnum").c_str())
Defaultctrl.cpp (serverframework\src\controller):            groupinfo.minprocnum_ = atoi(conf.GetChildAttrib("minprocnum").c_str());
Defaultctrl.cpp (serverframework\src\controller):        if(*conf.GetChildAttrib("heartbeat").c_str())
Defaultctrl.cpp (serverframework\src\controller):            groupinfo.heartbeat_ = atoi(conf.GetChildAttrib("heartbeat").c_str());
Defaultctrl.cpp (serverframework\src\controller):    	groupinfo.maxwatermark_ = atoi(conf.GetChildAttrib("watermark").c_str());
Defaultctrl.cpp (serverframework\src\controller):    	groupinfo.minsrate_ = atoi(conf.GetChildAttrib("minsrate").c_str());
Defaultctrl.cpp (serverframework\src\controller):    	groupinfo.maxdelay_ = atoi(conf.GetChildAttrib("maxdelay").c_str());
Defaultctrl.cpp (serverframework\src\controller):    	groupinfo.maxmemused_ = atoi(conf.GetChildAttrib("maxmemused").c_str());
Defaultctrl.cpp (serverframework\src\controller):    if(write(pid_file_fd, pid_buf, strlen(pid_buf)) != (int)strlen(pid_buf))
Defaultctrl.cpp (serverframework\src\controller):        string strPidFile = conf.GetAttrib("pidfile");
Defaultctrl.cpp (serverframework\src\controller):        WritePidFile(strPidFile.c_str());
Defaultctrl.cpp (serverframework\src\controller):        string strBasePath = commconf.GetAttrib("basepath");
Defaultctrl.cpp (serverframework\src\controller):        string strExeName = commconf.GetAttrib("exe");
Defaultctrl.cpp (serverframework\src\controller):        string strConf = commconf.GetAttrib("etc");
Defaultctrl.cpp (serverframework\src\controller):        string strFlag = commconf.GetAttrib("flag");
Defaultctrl.cpp (serverframework\src\controller):        assert(strBasePath != "");
Defaultctrl.cpp (serverframework\src\controller):        if(strExeName != "" )
Defaultctrl.cpp (serverframework\src\controller):            do_fork_ex(strBasePath.c_str(),strExeName.c_str(),strConf.c_str(),strFlag.c_str()) ;
Defaultctrl.cpp (serverframework\src\controller):        int log_level = atoi(commconf.GetAttrib("level").c_str());
Defaultctrl.cpp (serverframework\src\controller):        int log_type = atoi(commconf.GetAttrib("type").c_str());
Defaultctrl.cpp (serverframework\src\controller):        string log_path = commconf.GetAttrib("path");
Defaultctrl.cpp (serverframework\src\controller):        char * pLogPrefix =  strrchr(ix_->argv_[0],'/');
Defaultctrl.cpp (serverframework\src\controller):        string name_prefix =pLogPrefix;
Defaultctrl.cpp (serverframework\src\controller):        int max_file_size = atoi(commconf.GetAttrib("maxfilesize").c_str());
Defaultctrl.cpp (serverframework\src\controller):        int max_file_num = atoi(commconf.GetAttrib("maxfilenum").c_str());
Defaultctrl.cpp (serverframework\src\controller):        int log_key_base = strtol(commconf.GetAttrib("key_base").c_str(),0,0 );
Defaultctrl.cpp (serverframework\src\controller):        MkDir(log_path.c_str());
Defaultctrl.cpp (serverframework\src\controller):        log_level,log_type,log_path.c_str(),name_prefix.c_str(),max_file_size,max_file_num,logsemkey);
Defaultctrl.cpp (serverframework\src\controller):        m_log_internal.LOG_OPEN(log_level, log_type, log_path.c_str(), name_prefix.c_str(), max_file_size, max_file_num,logsemkey);
Defaultctrl.cpp (serverframework\src\controller):    int log_level = atoi(commconf.GetAttrib("level").c_str());
Defaultctrl.cpp (serverframework\src\controller):    int log_type = atoi(commconf.GetAttrib("type").c_str());
Defaultctrl.cpp (serverframework\src\controller):    string log_path = commconf.GetAttrib("path");
Defaultctrl.cpp (serverframework\src\controller):    char * pLogPrefix =  strrchr(ix_->argv_[0],'/');
Defaultctrl.cpp (serverframework\src\controller):    string name_prefix =pLogPrefix;
Defaultctrl.cpp (serverframework\src\controller):    int max_file_size = atoi(commconf.GetAttrib("maxfilesize").c_str());
Defaultctrl.cpp (serverframework\src\controller):    int max_file_num = atoi(commconf.GetAttrib("maxfilenum").c_str());
Defaultctrl.cpp (serverframework\src\controller):    int log_key_base = strtol(commconf.GetAttrib("key_base").c_str(),0,0 );
Defaultctrl.cpp (serverframework\src\controller):    MkDir(log_path.c_str());
Defaultctrl.cpp (serverframework\src\controller):    log_level,log_type,log_path.c_str(),name_prefix.c_str(),max_file_size,max_file_num,logsemkey);
Defaultctrl.cpp (serverframework\src\controller):    log_.LOG_OPEN(log_level, log_type, log_path.c_str(), name_prefix.c_str(), max_file_size, max_file_num,logsemkey);
Defaultctrl.cpp (serverframework\src\controller):    string mapfile = commconf.GetAttrib("mapfile");
Defaultctrl.cpp (serverframework\src\controller):    stat_output_interval_ = atoi(commconf.GetAttrib("interval").c_str() );
Defaultctrl.cpp (serverframework\src\controller):    stat_reset_days_ = atoi(commconf.GetAttrib("stat_reset_days").c_str());
Defaultctrl.cpp (serverframework\src\controller):    string stat_reset_time_ = commconf.GetAttrib("stat_reset_time");
Defaultctrl.cpp (serverframework\src\controller):        mapfile.c_str(),stat_output_file_.c_str(),stat_output_interval_,stat_reset_days_,
Defaultctrl.cpp (serverframework\src\controller):    	stat_.init_statpool(mapfile.c_str());
Defaultctrl.cpp (serverframework\src\controller):    ix_->moni_inter_time_ = atoi(commconf.GetAttrib("intervial").c_str());
Defaultctrl.cpp (serverframework\src\controller):    int moni_key_base = strtol(commconf.GetAttrib("key_base").c_str(),0,0);    
Defaultctrl.cpp (serverframework\src\controller):    int shmsize = atoi(commconf.GetAttrib("shmsize").c_str() );
Defaultctrl.cpp (serverframework\src\controller):        string strBasePath = commconf.GetAttrib("basepath");
Defaultctrl.cpp (serverframework\src\controller):        string strExeName = commconf.GetAttrib("exe");
Defaultctrl.cpp (serverframework\src\controller):        string strConf = commconf.GetAttrib("etc");
Defaultctrl.cpp (serverframework\src\controller):        string strFlag = commconf.GetAttrib("flag");
Defaultctrl.cpp (serverframework\src\controller):        assert(strBasePath != "");
Defaultctrl.cpp (serverframework\src\controller):        if(strExeName != "" )
Defaultctrl.cpp (serverframework\src\controller):            do_fork_ex(strBasePath.c_str(),strExeName.c_str(),strConf.c_str(),strFlag.c_str()) ;
Defaultctrl.cpp (serverframework\src\controller):        string strBasePath = commconf.GetAttrib("basepath");
Defaultctrl.cpp (serverframework\src\controller):        string strExeName = commconf.GetAttrib("exe");
Defaultctrl.cpp (serverframework\src\controller):        string strConf = commconf.GetAttrib("etc");
Defaultctrl.cpp (serverframework\src\controller):        string strFlag = commconf.GetAttrib("flag");
Defaultctrl.cpp (serverframework\src\controller):        assert(strBasePath != "");
Defaultctrl.cpp (serverframework\src\controller):        if(strExeName != "" )
Defaultctrl.cpp (serverframework\src\controller):            do_fork_ex(strBasePath.c_str(),strExeName.c_str(),strConf.c_str(),strFlag.c_str()) ;
Defaultctrl.h (serverframework\src\controller):    virtual void do_timer_callback(const struct timeval & nowtime){};
Defaultctrl.h (serverframework\src\controller):    string stat_output_file_;
Defaultctrl.h (serverframework\src\controller):    //string stat_reset_time_;
Defaultproxy.cpp (serverframework\src\proxy):#include <string.h>
Defaultproxy.cpp (serverframework\src\proxy):struct CServerBase::TInternal
Defaultproxy.cpp (serverframework\src\proxy):struct CDefaultProxy::IProxyParams
Defaultproxy.cpp (serverframework\src\proxy):    struct timeval now;
Defaultproxy.cpp (serverframework\src\proxy):    typedef struct tagQueryLoadInfo
Defaultproxy.cpp (serverframework\src\proxy):                string module_etc = conf.GetAttrib("etc");
Defaultproxy.cpp (serverframework\src\proxy):                sppdll.spp_handle_reloadconfig((void *) module_etc.c_str(),&blob,this);
Defaultproxy.cpp (serverframework\src\proxy):        int log_level = atoi(commconf.GetAttrib("level").c_str());
Defaultproxy.cpp (serverframework\src\proxy):        int log_type = atoi(commconf.GetAttrib("type").c_str());
Defaultproxy.cpp (serverframework\src\proxy):        string log_path = commconf.GetAttrib("path");
Defaultproxy.cpp (serverframework\src\proxy):        char * pLogPrefix =  strrchr(ix_->argv_[0],'/');
Defaultproxy.cpp (serverframework\src\proxy):        string name_prefix =pLogPrefix;
Defaultproxy.cpp (serverframework\src\proxy):        int max_file_size = atoi(commconf.GetAttrib("maxfilesize").c_str());
Defaultproxy.cpp (serverframework\src\proxy):        int max_file_num = atoi(commconf.GetAttrib("maxfilenum").c_str());
Defaultproxy.cpp (serverframework\src\proxy):        int log_key_base = strtol(commconf.GetAttrib("key_base").c_str(),0,0 );
Defaultproxy.cpp (serverframework\src\proxy):        m_log_internal.LOG_OPEN(log_level, log_type, log_path.c_str(), name_prefix.c_str(), max_file_size, max_file_num,semkey);
Defaultproxy.cpp (serverframework\src\proxy):    int log_level = atoi(commconf.GetAttrib("level").c_str());
Defaultproxy.cpp (serverframework\src\proxy):    int log_type = atoi(commconf.GetAttrib("type").c_str());
Defaultproxy.cpp (serverframework\src\proxy):    string log_path = commconf.GetAttrib("path");
Defaultproxy.cpp (serverframework\src\proxy):    char * pLogPrefix =  strrchr(ix_->argv_[0],'/');
Defaultproxy.cpp (serverframework\src\proxy):    string name_prefix =pLogPrefix;
Defaultproxy.cpp (serverframework\src\proxy):    int max_file_size = atoi(commconf.GetAttrib("maxfilesize").c_str());
Defaultproxy.cpp (serverframework\src\proxy):    int max_file_num = atoi(commconf.GetAttrib("maxfilenum").c_str());
Defaultproxy.cpp (serverframework\src\proxy):    int log_key_base = strtol(commconf.GetAttrib("key_base").c_str(),0,0 );
Defaultproxy.cpp (serverframework\src\proxy):    log_.LOG_OPEN(log_level, log_type, log_path.c_str(), name_prefix.c_str(), max_file_size, max_file_num,semkey);
Defaultproxy.cpp (serverframework\src\proxy):        string type = conf.GetAttrib("type");
Defaultproxy.cpp (serverframework\src\proxy):        socks.maxconn_ = atoi(conf.GetAttrib("maxconn").c_str());
Defaultproxy.cpp (serverframework\src\proxy):        socks.maxpkg_ = atoi(conf.GetAttrib("maxpkg").c_str());
Defaultproxy.cpp (serverframework\src\proxy):        socks.expiretime_ = atoi(conf.GetAttrib("timeout").c_str());	
Defaultproxy.cpp (serverframework\src\proxy):        socks.check_expire_interval_ = atoi(conf.GetAttrib("check_expire_interval").c_str());//检查连接超时时间间隔,0表示不检查
Defaultproxy.cpp (serverframework\src\proxy):                socks.sockbind_[i].ipport_.ip_ = CMisc::getip(conf.GetChildAttrib("if").c_str());
Defaultproxy.cpp (serverframework\src\proxy):                socks.sockbind_[i].ipport_.port_ = atoi(conf.GetChildAttrib("port").c_str());			
Defaultproxy.cpp (serverframework\src\proxy):                socks.sockbind_[i].ipport_.ip_ = CMisc::getip(conf.GetChildAttrib("if").c_str());
Defaultproxy.cpp (serverframework\src\proxy):                socks.sockbind_[i].ipport_.port_ = atoi(conf.GetChildAttrib("port").c_str());			
Defaultproxy.cpp (serverframework\src\proxy):                strncpy(socks.sockbind_[i].path_, conf.GetChildAttrib("path").c_str(), 256);
Defaultproxy.cpp (serverframework\src\proxy):            string type = conf.GetAttrib("type");
Defaultproxy.cpp (serverframework\src\proxy):                int send_size = atoi(commconf.GetAttrib("send_size").c_str());
Defaultproxy.cpp (serverframework\src\proxy):                int recv_size = atoi(commconf.GetAttrib("recv_size").c_str());
Defaultproxy.cpp (serverframework\src\proxy):                int shm_queue_key_base = strtol(commconf.GetAttrib("key_base").c_str(),0,0 );          
Defaultproxy.cpp (serverframework\src\proxy):    string mapfile = commconf.GetAttrib("mapfile");
Defaultproxy.cpp (serverframework\src\proxy):        stat_.init_statpool(mapfile.c_str());
Defaultproxy.cpp (serverframework\src\proxy):    ix_->moni_inter_time_ = atoi(commconf.GetAttrib("intervial").c_str());
Defaultproxy.cpp (serverframework\src\proxy):    int moni_key_base = strtol(commconf.GetAttrib("key_base").c_str(),0,0);
Defaultproxy.cpp (serverframework\src\proxy):    string module_file = conf.GetAttrib("bin");
Defaultproxy.cpp (serverframework\src\proxy):    string module_etc = conf.GetAttrib("etc");
Defaultproxy.cpp (serverframework\src\proxy):    FW_LOG_INFO("load module %s, %s\n", module_file.c_str(), module_etc.c_str());
Defaultproxy.cpp (serverframework\src\proxy):    if(0 == load_bench_adapter(module_file.c_str()))//加载用户定义库的内容
Defaultproxy.cpp (serverframework\src\proxy):        assert(sppdll.spp_handle_init((void*)module_etc.c_str(), this) == 0);
Defaultproxy.cpp (serverframework\src\proxy):    string local_handle_name=conf.GetAttrib("local_handle");
Defaultproxy.cpp (serverframework\src\proxy):        local_handle=(spp_handle_local_process_t)(dlsym(sppdll.handle,local_handle_name.c_str())); 
Defaultproxy.cpp (serverframework\src\proxy):        string iptable = "";
Defaultproxy.cpp (serverframework\src\proxy):            string black_table=conf.GetAttrib("blacklist");
Defaultproxy.cpp (serverframework\src\proxy):            FILE* fp = fopen(iptable.c_str(), "r");
Defaultproxy.cpp (serverframework\src\proxy):                struct in_addr ipaddr;
Defaultproxy.cpp (serverframework\src\proxy):void CDefaultProxy::do_timer_callback(const struct timeval & nowtime )
Defaultproxy.cpp (serverframework\src\proxy):            proxy->m_log_internal.LOG_P_LEVEL(LOG_ERROR, "ip white limited, %s\n", inet_ntoa(*((struct in_addr*)&extinfo->remoteip_)));
Defaultproxy.cpp (serverframework\src\proxy):            proxy->m_log_internal.LOG_P_LEVEL(LOG_ERROR, "ip black limited, %s\n", inet_ntoa(*((struct in_addr*)&extinfo->remoteip_)));
Defaultproxy.cpp (serverframework\src\proxy):    proxy->m_log_internal.LOG_P_LEVEL(LOG_DEBUG,"flow=%u,remote ip=%s,remote port=%d\n",flow,inet_ntoa(*((struct in_addr*)&extinfo->remoteip_)),extinfo->remoteport_);
Defaultproxy.h (serverframework\src\proxy):    virtual void do_timer_callback(const struct timeval & nowtime);
Defaultproxy.h (serverframework\src\proxy):    struct IProxyParams;//代理的私有数据结构
Defaultworker.cpp (serverframework\src\worker):#include <string.h>
Defaultworker.cpp (serverframework\src\worker):struct CServerBase::TInternal
Defaultworker.cpp (serverframework\src\worker):static int AllTrim(string & str)
Defaultworker.cpp (serverframework\src\worker):    str.erase( std::remove(str.begin(), str.end(), ' '), str.end());
Defaultworker.cpp (serverframework\src\worker):                string strSendData;
Defaultworker.cpp (serverframework\src\worker):                strSendData.assign((char *) blob->data,blob->len);
Defaultworker.cpp (serverframework\src\worker):                        blob->len = strSendData.size();
Defaultworker.cpp (serverframework\src\worker):                        memcpy(blob->data,strSendData.data(),blob->len );                                            
Defaultworker.cpp (serverframework\src\worker):        string strSendData;
Defaultworker.cpp (serverframework\src\worker):        strSendData.assign((char *) blob->data,blob->len);
Defaultworker.cpp (serverframework\src\worker):                blob->len = strSendData.size();
Defaultworker.cpp (serverframework\src\worker):                memcpy(blob->data,strSendData.data(),blob->len );
Defaultworker.cpp (serverframework\src\worker):    struct timeval now;
Defaultworker.cpp (serverframework\src\worker):                string module_etc = conf.GetAttrib("etc");
Defaultworker.cpp (serverframework\src\worker):                sppdll.spp_handle_reloadconfig((void *) module_etc.c_str(),&blob,this);
Defaultworker.cpp (serverframework\src\worker):        int log_level = atoi(commconf.GetAttrib("level").c_str());
Defaultworker.cpp (serverframework\src\worker):        int log_type = atoi(commconf.GetAttrib("type").c_str());
Defaultworker.cpp (serverframework\src\worker):        string log_path = commconf.GetAttrib("path");
Defaultworker.cpp (serverframework\src\worker):        char * pLogPrefix =  strrchr(ix_->argv_[0],'/');
Defaultworker.cpp (serverframework\src\worker):        string name_prefix =szLogPrefix;
Defaultworker.cpp (serverframework\src\worker):        int max_file_size = atoi(commconf.GetAttrib("maxfilesize").c_str());
Defaultworker.cpp (serverframework\src\worker):        int max_file_num = atoi(commconf.GetAttrib("maxfilenum").c_str());
Defaultworker.cpp (serverframework\src\worker):        int log_key_base = strtol(commconf.GetAttrib("key_base").c_str(),0,0 );
Defaultworker.cpp (serverframework\src\worker):        m_log_internal.LOG_OPEN(log_level, log_type, log_path.c_str(), name_prefix.c_str(), max_file_size, max_file_num, semkey);
Defaultworker.cpp (serverframework\src\worker):    int log_level = atoi(commconf.GetAttrib("level").c_str());
Defaultworker.cpp (serverframework\src\worker):    int log_type = atoi(commconf.GetAttrib("type").c_str());
Defaultworker.cpp (serverframework\src\worker):    string log_path = commconf.GetAttrib("path");
Defaultworker.cpp (serverframework\src\worker):    char * pLogPrefix =  strrchr(ix_->argv_[0],'/');
Defaultworker.cpp (serverframework\src\worker):    string name_prefix =szLogPrefix;
Defaultworker.cpp (serverframework\src\worker):    int max_file_size = atoi(commconf.GetAttrib("maxfilesize").c_str());
Defaultworker.cpp (serverframework\src\worker):    int max_file_num = atoi(commconf.GetAttrib("maxfilenum").c_str());
Defaultworker.cpp (serverframework\src\worker):    int log_key_base = strtol(commconf.GetAttrib("key_base").c_str(),0,0 );
Defaultworker.cpp (serverframework\src\worker):    log_.LOG_OPEN(log_level, log_type, log_path.c_str(), name_prefix.c_str(), max_file_size, max_file_num, semkey);
Defaultworker.cpp (serverframework\src\worker):        string type = conf.GetAttrib("type");
Defaultworker.cpp (serverframework\src\worker):        string maxconn = conf.GetAttrib("maxconn");
Defaultworker.cpp (serverframework\src\worker):        string maxpkg = conf.GetAttrib("maxpkg");
Defaultworker.cpp (serverframework\src\worker):        string timeout = conf.GetAttrib("timeout");
Defaultworker.cpp (serverframework\src\worker):        string max_poll_pkg = conf.GetAttrib("max_poll_pkg");
Defaultworker.cpp (serverframework\src\worker):            int recv_size = atoi(commconf.GetAttrib("send_size").c_str());
Defaultworker.cpp (serverframework\src\worker):            int send_size = atoi(commconf.GetAttrib("recv_size").c_str());
Defaultworker.cpp (serverframework\src\worker):            int shm_queue_key_base = strtol(commconf.GetAttrib("key_base").c_str() ,0,0);
Defaultworker.cpp (serverframework\src\worker):            shm.msg_timeout_ = atoi(timeout.c_str()) ;
Defaultworker.cpp (serverframework\src\worker):            shm.maxpkg_ = atoi(maxpkg.c_str());
Defaultworker.cpp (serverframework\src\worker):            socks.maxconn_ = atoi(maxconn.c_str());
Defaultworker.cpp (serverframework\src\worker):            socks.maxpkg_ = atoi(maxpkg.c_str());
Defaultworker.cpp (serverframework\src\worker):            socks.expiretime_ = atoi(timeout.c_str());
Defaultworker.cpp (serverframework\src\worker):                socks.sockbind_[0].ipport_.ip_ = CMisc::getip(conf.GetAttrib("if").c_str());
Defaultworker.cpp (serverframework\src\worker):                socks.sockbind_[0].ipport_.port_ = atoi(conf.GetAttrib("port").c_str());            
Defaultworker.cpp (serverframework\src\worker):                socks.sockbind_[0].ipport_.ip_ = CMisc::getip(conf.GetAttrib("if").c_str());
Defaultworker.cpp (serverframework\src\worker):                socks.sockbind_[0].ipport_.port_ = atoi(conf.GetAttrib("port").c_str());            
Defaultworker.cpp (serverframework\src\worker):                strncpy(socks.sockbind_[0].path_, conf.GetChildAttrib("path").c_str(), 256);
Defaultworker.cpp (serverframework\src\worker):            string type = conf.GetAttrib("type");
Defaultworker.cpp (serverframework\src\worker):                route_config_->max_conn_ = atoi(conf.GetAttrib("maxconn").c_str());
Defaultworker.cpp (serverframework\src\worker):                route_config_->maxpkg_ = atoi(conf.GetAttrib("maxpkg").c_str());//每秒最大包量
Defaultworker.cpp (serverframework\src\worker):                route_config_->expiretime_ = atoi(conf.GetAttrib("timeout").c_str());    
Defaultworker.cpp (serverframework\src\worker):                route_config_->check_expire_interval_ = atoi(conf.GetAttrib("check_expire_interval").c_str());//检查连接超时时间间隔
Defaultworker.cpp (serverframework\src\worker):                string strRouteTable = conf.GetAttrib("route_table");//路由表文件
Defaultworker.cpp (serverframework\src\worker):                assert( 0 == InitRouteConfig(route_config_,strRouteTable,reload) );
Defaultworker.cpp (serverframework\src\worker):    string mapfile = commconf.GetAttrib("mapfile");
Defaultworker.cpp (serverframework\src\worker):        stat_.init_statpool(mapfile.c_str());
Defaultworker.cpp (serverframework\src\worker):    ix_->moni_inter_time_ = atoi(commconf.GetAttrib("intervial").c_str());
Defaultworker.cpp (serverframework\src\worker):    int moni_key_base = strtol(commconf.GetAttrib("key_base").c_str(),0,0);
Defaultworker.cpp (serverframework\src\worker):    string module_file = conf.GetAttrib("bin");
Defaultworker.cpp (serverframework\src\worker):    string module_etc = conf.GetAttrib("etc");
Defaultworker.cpp (serverframework\src\worker):    FW_LOG_INFO("load module %s, %s\n", module_file.c_str(), module_etc.c_str());
Defaultworker.cpp (serverframework\src\worker):    if(0 == load_bench_adapter(module_file.c_str()))//加载用户定义库的内容
Defaultworker.cpp (serverframework\src\worker):        assert(sppdll.spp_handle_init((void*)module_etc.c_str(), this) == 0);
Defaultworker.cpp (serverframework\src\worker):int CDefaultWorker::InitRouteConfig(TRouteConfig * config, const string & route_file, bool reload)
Defaultworker.cpp (serverframework\src\worker):        conf.Load(route_file.c_str() );// route_table.xml
Defaultworker.cpp (serverframework\src\worker):        string base_path = conf.GetAttrib("basepath");
Defaultworker.cpp (serverframework\src\worker):        string route_prefix = conf.GetAttrib("prefix");//读取route_table_00000001.xml
Defaultworker.cpp (serverframework\src\worker):            unsigned int serv_type =strtol(conf.GetChildAttrib("serv_type").c_str(),0,0);//支持0X配置
Defaultworker.cpp (serverframework\src\worker):            sprintf(route_cfg,"%s/%s_%08x.xml",base_path.c_str(),route_prefix.c_str(),serv_type);//route_table_00000001.xml
Defaultworker.cpp (serverframework\src\worker):int CDefaultWorker::InitRouteTable(TRouteTable & route_tbl, const string & route_cfg)
Defaultworker.cpp (serverframework\src\worker):    conf.Load(route_cfg.c_str() );//route_table_00000001.xml
Defaultworker.cpp (serverframework\src\worker):    string strVersion = conf.GetAttrib("version");
Defaultworker.cpp (serverframework\src\worker):    unsigned int serv_type = strtol(conf.GetAttrib("serv_type").c_str(),0,0);
Defaultworker.cpp (serverframework\src\worker):    route_tbl.version_ = strVersion;
Defaultworker.cpp (serverframework\src\worker):    string strRoute = conf.GetAttrib("route");// "key % 1"
Defaultworker.cpp (serverframework\src\worker):    AllTrim(strRoute);
Defaultworker.cpp (serverframework\src\worker):    if(strRoute != "" )
Defaultworker.cpp (serverframework\src\worker):        assert(strRoute.substr(0,3) == "key" );        
Defaultworker.cpp (serverframework\src\worker):        route_tbl.route_  = strRoute.substr(3,1);// %
Defaultworker.cpp (serverframework\src\worker):        route_tbl.route_val_ = atoi(strRoute.substr(4,strRoute.size() - 4 ).c_str() );// 1
Defaultworker.cpp (serverframework\src\worker):        FW_LOG_INFO("route=%s,route_arithmetic=%s,route_val=%d\n",strRoute.c_str(),route_tbl.route_.c_str(),route_tbl.route_val_);
Defaultworker.cpp (serverframework\src\worker):        string strType = conf.GetChildAttrib("type");
Defaultworker.cpp (serverframework\src\worker):        nodeinfo.node_id_ = atoi(conf.GetChildAttrib("id").c_str());
Defaultworker.cpp (serverframework\src\worker):        if(strType == "tcp")
Defaultworker.cpp (serverframework\src\worker):            ret = CSocketAddr::in_s2n((conf.GetChildAttrib("serv_addr").c_str()), nodeinfo.bind_.ipport_.ip_);
Defaultworker.cpp (serverframework\src\worker):            nodeinfo.bind_.ipport_.port_ = atoi(conf.GetChildAttrib("port").c_str());            
Defaultworker.cpp (serverframework\src\worker):        else if(strType == "udp")
Defaultworker.cpp (serverframework\src\worker):            ret = CSocketAddr::in_s2n((conf.GetChildAttrib("serv_addr").c_str()), nodeinfo.bind_.ipport_.ip_);
Defaultworker.cpp (serverframework\src\worker):            nodeinfo.bind_.ipport_.port_ = atoi(conf.GetChildAttrib("port").c_str());            
Defaultworker.cpp (serverframework\src\worker):        else if(strType == "unix")
Defaultworker.cpp (serverframework\src\worker):            strncpy(nodeinfo.bind_.path_, conf.GetChildAttrib("path").c_str(), 256);
Defaultworker.cpp (serverframework\src\worker):        nodeinfo.begin_ = atoi(conf.GetChildAttrib("begin").c_str());
Defaultworker.cpp (serverframework\src\worker):        nodeinfo.end_ = atoi( conf.GetChildAttrib("end").c_str() );
Defaultworker.cpp (serverframework\src\worker):void CDefaultWorker::do_timer_callback(const struct timeval & nowtime )
Defaultworker.h (serverframework\src\worker):    virtual void do_timer_callback(const struct timeval & nowtime );
Defaultworker.h (serverframework\src\worker):    int InitRouteTable(TRouteTable & route_tbl,const string & route_cfg);
Defaultworker.h (serverframework\src\worker):    int InitRouteConfig(TRouteConfig * config,const string & route_file,bool reload);
Epoller.cpp (serverframework\src\base):        throw std::runtime_error("epoll_create fail [" + std::string(strerror(errno)) + "]");
Epoller.cpp (serverframework\src\base):            throw std::runtime_error("epoll_wait fail [" + std::string(strerror(errno)) + "]");
Epoller.cpp (serverframework\src\base):            //std::cerr << strerror(errno) << std::endl;
Epoller.cpp (serverframework\src\base):        throw std::runtime_error("epoll_ctl fail [" + std::string(strerror(errno)) + "]");
Epoller.h (serverframework\include):#include <string.h>
Epoller.h (serverframework\include):#include <string>
Epoller.h (serverframework\include):#include <iostream>
Epollflow.h (serverframework\include):#include <string.h>
Epollflow.h (serverframework\include):#include <string>
Epollflow.h (serverframework\include):#include <iostream>
Fifo.cpp (libcomm\src\communi):fifo_fail::fifo_fail(const string & s):runtime_error(s) {}
Fifo.cpp (libcomm\src\communi):fifo_delay::fifo_delay(const string & s):runtime_error(s) {}
Fifo.cpp (libcomm\src\communi):        throw fifo_fail(string("CFifo set_nonblock:")+strerror(errno));
Fifo.cpp (libcomm\src\communi):        throw fifo_fail(string("CFifo set_nonblock:")+strerror(errno));
Fifo.cpp (libcomm\src\communi):            throw fifo_fail(string("mkfifo fifo ")+pathname+" fail");
Fifo.cpp (libcomm\src\communi):            throw fifo_fail(string("open read fifo fail")+strerror(errno));
Fifo.cpp (libcomm\src\communi):            throw fifo_fail(string("open write fifo fail:")+strerror(errno));
Fifo.cpp (libcomm\src\communi):                throw fifo_fail(string("read fifo fail:")+strerror(errno));
Fifo.cpp (libcomm\src\communi):        _fd = ::open(_pathname.c_str(),O_NONBLOCK|O_WRONLY);
Fifo.cpp (libcomm\src\communi):                throw fifo_delay(string("CFifo: open write fifo fail:")+strerror(errno));
Fifo.cpp (libcomm\src\communi):            throw fifo_fail(string("CFifo: open write fifo fail:")+strerror(errno));
Fifo.cpp (libcomm\src\communi):                throw fifo_delay(string("CFifo write EAGAIN|EPIPE:")+strerror(errno));
Fifo.cpp (libcomm\src\communi):                throw fifo_fail(string("write fifo fail:")+strerror(errno));
Fifo.h (libcomm\include):#include <iostream>
Fifo.h (libcomm\include):struct fifo_fail: public runtime_error{ fifo_fail(const string& s);};
Fifo.h (libcomm\include):struct fifo_delay: public runtime_error{ fifo_delay(const string& s);};
Fifo.h (libcomm\include):    string _pathname;
HashMap.hpp (libcomm\include):typedef struct tagTHashPara
HashMap.hpp (libcomm\include):typedef struct tagTHashInfo
HashMap.hpp (libcomm\include):struct HashNode
HashMap.hpp (libcomm\include):typedef struct tagTHashMap
Hexdump.cpp (libcomm\src\util):#include <string.h>
Hexdump.cpp (libcomm\src\util):#include <fstream>
Hexdump.cpp (libcomm\src\util):#include <iostream>
Inifile.cpp (libcomm\src\base):#include <string.h>
Inifile.cpp (libcomm\src\base):#include <strings.h>
Inifile.cpp (libcomm\src\base):#include <fstream>
Inifile.cpp (libcomm\src\base):    m_pszFilename = strdup(pszFilename);
Inifile.cpp (libcomm\src\base):        pszReturnedString - 指定用于接收结果的缓冲区地址
Inifile.cpp (libcomm\src\base):                                  char *pszReturnedString,
Inifile.cpp (libcomm\src\base):    len = GetItemValue(pszSectionName, pszKeyName, pszReturnedString, nSize);
Inifile.cpp (libcomm\src\base):        strncpy(pszReturnedString, pszDefaultValue, nSize-1);
Inifile.cpp (libcomm\src\base):        pszReturnedString[nSize-1] = '\0';
Inifile.cpp (libcomm\src\base):        return strlen(pszReturnedString);
Inifile.cpp (libcomm\src\base):        pszReturnedString - 指定用于接收结果的缓冲区地址
Inifile.cpp (libcomm\src\base):                                  char *pszReturnedString,
Inifile.cpp (libcomm\src\base):        || (NULL == pszReturnedString))
Inifile.cpp (libcomm\src\base):        pszReturnedString[dwCount] = *pszValueBegin;
Inifile.cpp (libcomm\src\base):    pszReturnedString[dwCount] = '\0';
Inifile.cpp (libcomm\src\base):    if ((dwCount == nSize-1) && ((BYTE)(pszReturnedString[dwCount-1]) > 0x7f))
Inifile.cpp (libcomm\src\base):        pszReturnedString[dwCount-1] = '\0';
Inifile.cpp (libcomm\src\base):    len = strlen(pszKeyName) + strlen(pszKeyValue) + 5;
Inifile.cpp (libcomm\src\base):	len = strlen(pszKeyName) + strlen(pszKeyValue) + 4;
Inifile.cpp (libcomm\src\base):  Calls:        CConfigFile::LocateStr
Inifile.cpp (libcomm\src\base):    pszLowerSection = new char [strlen(pszSectionName) + 2 + 1];
Inifile.cpp (libcomm\src\base):    ToLower(pszLowerSection, strlen(pszLowerSection));
Inifile.cpp (libcomm\src\base):    pszSectionBeginOnShadow = LocateStr( pszLowerSection,
Inifile.cpp (libcomm\src\base):                                    + strlen(pszLowerSection);
Inifile.cpp (libcomm\src\base):                CConfigFile::LocateStr
Inifile.cpp (libcomm\src\base):    pszLowerKey = strdup(pszKeyName);
Inifile.cpp (libcomm\src\base):    ToLower(pszLowerKey, strlen(pszLowerKey));
Inifile.cpp (libcomm\src\base):    pszKeyBeginOnShadow = LocateStr( pszLowerKey,
Inifile.cpp (libcomm\src\base):    pszKeyEnd = pszKeyBegin + strlen(pszKeyName);
Inifile.cpp (libcomm\src\base):                CConfigFile::LocateStr
Inifile.cpp (libcomm\src\base):    pszLowerKey = strdup(pszKeyName);
Inifile.cpp (libcomm\src\base):    ToLower(pszLowerKey, strlen(pszLowerKey));
Inifile.cpp (libcomm\src\base):    pszKeyBeginOnShadow = LocateStr( pszLowerKey,
Inifile.cpp (libcomm\src\base):    pszValueBegin = MapToContent(pszKeyBeginOnShadow) + strlen(pszKeyName);
Inifile.cpp (libcomm\src\base):  Function:     LocateStr
Inifile.cpp (libcomm\src\base):char *CIniFile::LocateStr( const char *pszCharSet,
Inifile.cpp (libcomm\src\base):    pFind = SearchMarchStr(pszBegin, pszCharSet);
Inifile.cpp (libcomm\src\base):	//pFind = strstr(pszBegin, pszCharSet);
Inifile.cpp (libcomm\src\base):    if ((NULL == pFind) || ((pFind + strlen(pszCharSet)) > pszEnd))
Inifile.cpp (libcomm\src\base):char *CIniFile::SearchMarchStr(const char *pszBegin, const char *pszCharSet)
Inifile.cpp (libcomm\src\base):		pFind = strstr(pTempBegin, pszCharSet);
Inifile.cpp (libcomm\src\base):                pTempBegin = pFind + strlen(pszCharSet);
Inifile.cpp (libcomm\src\base):		pFind1 = pFind + strlen(pszCharSet);
Inifile.cpp (libcomm\src\base):		pTempBegin = pFind + strlen(pszCharSet);
Inifile.cpp (libcomm\src\base):        strlwr在处理某些汉字编码时，会出错，导致汉字编码被改变
Inifile.h (libcomm\include):            pszReturnedString - 指定用于接收结果的缓冲区地址
Inifile.h (libcomm\include):                        char *pszReturnedString, 
Inifile.h (libcomm\include):            pszReturnedString - 指定用于接收结果的缓冲区地址
Inifile.h (libcomm\include):                        char *pszReturnedString, 
Inifile.h (libcomm\include):    char *LocateStr(    const char *pszCharSet, 
Inifile.h (libcomm\include):    char *SearchMarchStr(const char *pszBegin, const char *pszCharSet);
Jcache_fieldid.h (libprotocol\include):const unsigned int TblArticle_Title = 0x00050004;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblArticle_ArticleLabel = 0x0005000A;  //string32
Jcache_fieldid.h (libprotocol\include):const unsigned int TblAccount_Account = 0x00060001;  //string64
Jcache_fieldid.h (libprotocol\include):const unsigned int TblBasicInfo_Name = 0x00070002;  //string64
Jcache_fieldid.h (libprotocol\include):const unsigned int TblBasicInfo_Account = 0x0007000C;  //string64
Jcache_fieldid.h (libprotocol\include):const unsigned int TblEmailInfo_Email = 0x00080001;  //string64
Jcache_fieldid.h (libprotocol\include):const unsigned int TblEmailInfo_WebLink = 0x00080002;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblEmailInfo_Smtp = 0x00080003;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblEmailInfo_Pop = 0x00080004;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblArtStat_Vistor = 0x000B0005;  //string128
Jcache_fieldid.h (libprotocol\include):const unsigned int TblArticleSort_SortName = 0x000C0003;  //string32
Jcache_fieldid.h (libprotocol\include):const unsigned int TblDeepInfo_Telephone = 0x000D000e;  //string32
Jcache_fieldid.h (libprotocol\include):const unsigned int TblAccountVerify_Account = 0x000E0001;  //string64
Jcache_fieldid.h (libprotocol\include):const unsigned int TblAccountVerify_VerifyCode = 0x000E0002;  //string64
Jcache_fieldid.h (libprotocol\include):const unsigned int TblAccountVerify_Name = 0x000E0005;  //string64
Jcache_fieldid.h (libprotocol\include):const unsigned int TblAccountVerify_old_account = 0x000E000C;  //string64
Jcache_fieldid.h (libprotocol\include):const unsigned int TblAlbum_AlbumName = 0x000F0003;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblAlbum_converPicPath = 0x000F0004;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblAlbum_AlbumTag = 0x000F000C;  //string32
Jcache_fieldid.h (libprotocol\include):const unsigned int TblPicture_PicPath = 0x00100005;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblPicture_ThumbPath = 0x00100006;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblPicture_PicComment = 0x00100007;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblPicture_PicTag = 0x00100008;  //string64
Jcache_fieldid.h (libprotocol\include):const unsigned int TblAlbumComment_CommentContent = 0x00110008;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblAlbumStat_Vistor = 0x00120005;  //string128
Jcache_fieldid.h (libprotocol\include):const unsigned int TblFriend_FriendMemo = 0x00130005;  //string64
Jcache_fieldid.h (libprotocol\include):const unsigned int TblGroup_GroupName = 0x00140003;  //string64
Jcache_fieldid.h (libprotocol\include):const unsigned int TblSignInfo_Sign = 0x00180002;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblContacts_Email = 0x00190002;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblContacts_Mobile = 0x00190003;  //string20
Jcache_fieldid.h (libprotocol\include):const unsigned int TblContacts_Phone = 0x00190004;  //string20
Jcache_fieldid.h (libprotocol\include):const unsigned int TblContacts_Fax = 0x00190005;  //string20
Jcache_fieldid.h (libprotocol\include):const unsigned int TblContacts_Address = 0x00190006;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblContacts_QQ = 0x00190007;  //string20
Jcache_fieldid.h (libprotocol\include):const unsigned int TblContacts_MSN = 0x00190008;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblContacts_Skype = 0x00190009;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblWorks_Company = 0x001A0003;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblWorks_Job = 0x001A0004;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblEducations_School = 0x001B0003;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblEducations_Class = 0x001B0004;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblFace_FaceHash = 0x001C0004;  //string64
Jcache_fieldid.h (libprotocol\include):const unsigned int TblPwdProtect_Mobile = 0x001D0002;  //string20
Jcache_fieldid.h (libprotocol\include):const unsigned int TblPwdProtect_Email = 0x001D0003;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblPwdProtect_Answer1 = 0x001D0005;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblPwdProtect_Answer2 = 0x001D0007;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblPwdProtect_Answer3 = 0x001D0009;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblStkGroup_StkGrpName = 0x001E0003;  //string64
Jcache_fieldid.h (libprotocol\include):const unsigned int TblStkInfo_StkCode = 0x001F0002;  //string6
Jcache_fieldid.h (libprotocol\include):const unsigned int TblStkInfo_StkName = 0x001F0003;  //string48
Jcache_fieldid.h (libprotocol\include):const unsigned int TblStkInfo_StkShortName = 0x001F0005;  //string48
Jcache_fieldid.h (libprotocol\include):const unsigned int TblStkUser_StkCode = 0x00200004;  //string6
Jcache_fieldid.h (libprotocol\include):const unsigned int TblSysMsg_UserName = 0x0025000E;  //string64
Jcache_fieldid.h (libprotocol\include):const unsigned int TblSysMsg_Remark = 0x0025000F;  //string256
Jcache_fieldid.h (libprotocol\include):const unsigned int TblDiscussInfo_Name = 0x00260002;  //string64
Jcache_fieldid.h (libprotocol\include):const unsigned int TblGrpBasicInfo_Name = 0x00270002;  //string128
Jcache_fieldid.h (libprotocol\include):const unsigned int TblGrpFace_FaceHash = 0x002a0004;  //string64
Jcache_fieldid.h (libprotocol\include):const unsigned int TblNoteInBox_Content = 0x002f0004;  //string600
Jcache_fieldid.h (libprotocol\include):const unsigned int TblNoteOutBox_Content = 0x00300004;  //string600
Jcache_fieldid.h (libprotocol\include):const unsigned int TblWebSysMsg_Content = 0x00310004;  //string512
Jcache_fieldid.h (libprotocol\include):const unsigned int TblFriendReqMsg_Content = 0x00320004;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblFriendNews_reserved_1 = 0x00330008;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblFriendNews_reserved_2 = 0x00330009;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblFriendInvite_email_addr = 0x00390001;  //string128
Jcache_fieldid.h (libprotocol\include):const unsigned int TblAppInfo_AppName = 0x00400002;  //string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblMyMood_Content = 0x00460004;  //string800
Jcache_fieldid.h (libprotocol\include):const unsigned int TblGrpTypeName_ClassName = 0x00490003;  //string128
Jcache_fieldid.h (libprotocol\include):const unsigned int TblActIDCfg_Remark = 0x004b0003;  //string256
Jcache_fieldid.h (libprotocol\include):const unsigned int TblActKeyIDCfg_Remark = 0x004c0004;  //string256
Jcache_fieldid.h (libprotocol\include):const unsigned int TblGrpHotKeywords_HotKeyWord = 0x004d0001;  //string128
Jcache_fieldid.h (libprotocol\include):const unsigned int TblGrpActive_Content = 0x004e0005;  //string512
Jcache_fieldid.h (libprotocol\include):const unsigned int TblGrpNote_Content = 0x004f0005;  //string512
Jcache_fieldid.h (libprotocol\include):const unsigned int TblLoginHis_Account = 0x00530002;  //string64
Jcache_fieldid.h (libprotocol\include):const unsigned int TblAlarmRecvSetting_Email = 0x00550003;  //string128
Jcache_fieldid.h (libprotocol\include):const unsigned int TblAlarmRecvSetting_Mphone = 0x00550004;  //string32
Jcache_fieldid.h (libprotocol\include):const unsigned int TblAlarmRecvSetting_ActivateEmail = 0x00550005;  //string128
Jcache_fieldid.h (libprotocol\include):const unsigned int TblAlarmRecvSetting_EmailVCode = 0x00550006;  //string32
Jcache_fieldid.h (libprotocol\include):const unsigned int TblAlarmRecvSetting_ActivateMPhone = 0x00550008;  //string128
Jcache_fieldid.h (libprotocol\include):const unsigned int TblAlarmRecvSetting_MPhoneVCode = 0x00550009;  //string32
Jcache_fieldid.h (libprotocol\include):const unsigned int TblMsgInbox_Content = 0x00580005;  //string1024
Jcache_fieldid.h (libprotocol\include):const unsigned int TblMsgInnMail_Content = 0x00590005;  //string800
Jcache_fieldid.h (libprotocol\include):const unsigned int TblFileInfo_FileHashCode = 0x005b0002;  //string128
Jcache_fieldid.h (libprotocol\include):const unsigned int TblStkBoardInfo_BoardID = 0x005d0001;  //string16
Jcache_fieldid.h (libprotocol\include):const unsigned int TblStkBoardInfo_BoardName = 0x005d0002;  //string64
Jcache_fieldid.h (libprotocol\include):const unsigned int TblStkBoardInfo_BoardPID = 0x005d0003;  //string16
Jcache_fieldid.h (libprotocol\include):const unsigned int TblSysCfg_Section = 0x00600002;  //string50
Jcache_fieldid.h (libprotocol\include):const unsigned int TblSysCfg_CfgName = 0x00600003;  //string50
Jcache_fieldid.h (libprotocol\include):const unsigned int TblSysCfg_CfgValue = 0x00600004;  //string2000
Jcache_fieldid.h (libprotocol\include):const unsigned int TblSysCfg_Remark = 0x00600005;  //string200
Jcache_fieldid.h (libprotocol\include):const unsigned int TblGrpBBSPost_Title = 0x00610004;  //string128
Jcache_fieldid.h (libprotocol\include):const unsigned int TblGrpBBSPost_LastReplyTime = 0x00610009;  //int32
Jcache_fieldid.h (libprotocol\include):const unsigned int TblBannerCfg_FileUrl = 0x00650002;  //string256
Jcache_fieldid.h (libprotocol\include):const unsigned int TblBannerCfg_FileHash = 0x00650003;  //string256
Jcache_fieldid.h (libprotocol\include):const unsigned int TblBannerCfg_LinkUrl = 0x00650004;  //string256
Jcache_fieldid.h (libprotocol\include):const unsigned int TblBannerCfg_Remark = 0x0065000c;  //string200
Jcache_fieldid.h (libprotocol\include):const unsigned int TblMObileBind_Mobile1 = 0x00660002;  //string20
Jcache_fieldid.h (libprotocol\include):const unsigned int TblMObileBind_Mobile2 = 0x00660004;  //string20
Jcache_fieldid.h (libprotocol\include):const unsigned int TblMObileBind_Mobile3 = 0x00660006;  //string20
Jcache_fieldid.h (libprotocol\include):const unsigned int TblMObileBind_Mobile4 = 0x00660008;  //string20
Jcache_fieldid.h (libprotocol\include):const unsigned int TblMObileBind_Mobile5 = 0x0066000a;  //string20
Jcache_fieldid.h (libprotocol\include):const unsigned int TblMObileBind_Mobile6 = 0x0066000c;  //string20
Jcache_fieldid.h (libprotocol\include):const unsigned int TblMblogUser_Description = 0x00670004;  //string512
Jcache_fieldid.h (libprotocol\include):const unsigned int TblMblogHistory_Content = 0x00680003; //string512
Jcache_fieldid.h (libprotocol\include):const unsigned int TblMblogHistory_InfoStr = 0x0068000a;  //string1024
Jcache_fieldid.h (libprotocol\include):const unsigned int TblMblogCelebrity_Description = 0x00690004;  //string512
Jcache_fieldid.h (libprotocol\include):const unsigned int TblMblogTopic_TopicName = 0x006d0002;  //string512
Jcache_fieldid.h (libprotocol\include):const unsigned int TblFeedback_Title = 0x00700002;  //string512
Jcache_fieldid.h (libprotocol\include):const unsigned int TblFeedback_Description = 0x00700004;  //string512
Jcache_fieldid.h (libprotocol\include):const unsigned int TblFeedback_Contact = 0x00700005;  //string256
Jcache_fieldid.h (libprotocol\include):const unsigned int TblStkNowData_StockCode                  = 0x00710003;    //  string8
Jcache_fieldid.h (libprotocol\include):const unsigned int TblStkMinuteData_StockCode               = 0x00720003;    //  string8
Jcache_fieldid.h (libprotocol\include):const unsigned int TblIndexMinuteData_StockCode             = 0x00730003;    //  string8
Jcache_fieldid.h (libprotocol\include):const unsigned int TblIndexNowData_StockCode                = 0x00740003;    //  string8
Jcache_fieldid.h (libprotocol\include):const unsigned int TblRegHis_Account                        = 0x00760001;    //  string64
Jcache_fieldid.h (libprotocol\include):const unsigned int TblFeedsCfg_Dest_UIN_Key                 = 0x00780004;    //  string128
Jcache_fieldid.h (libprotocol\include):const unsigned int TblFeedsCfg_Dest_Name_Key                = 0x00780005;    //  string128
Jcache_fieldid.h (libprotocol\include):const unsigned int TblFeedsCfg_Marker                       = 0x00780007;    //  string256
Jcache_fieldid.h (libprotocol\include):const unsigned int TblVoteInfo_Subject                      = 0x007b000d;    //  string255
Jcache_fieldid.h (libprotocol\include):const unsigned int TblMobileArea_MobileArea                    = 0x00820002;    //  string30
Jcache_fieldid.h (libprotocol\include):const unsigned int TblMobileArea_Province                      = 0x00820003;    //  string50
Jcache_fieldid.h (libprotocol\include):const unsigned int TblMobileArea_City                          = 0x00820004;    //  string50
Jcache_fieldid.h (libprotocol\include):const unsigned int TblMobileArea_AreaCode                      = 0x00820005;    //  string30
List.h (serverframework\include):struct list_head {
List.h (serverframework\include):	struct list_head *next, *prev;
List.h (serverframework\include):typedef struct list_head list_head_t;
List.h (serverframework\include):    struct list_head name = LIST_HEAD_INIT(name)
List.h (serverframework\include):static inline void __list_add(struct list_head *newe,
List.h (serverframework\include):			      struct list_head *prev,
List.h (serverframework\include):			      struct list_head *next)
List.h (serverframework\include):static inline void list_add(struct list_head *newe, struct list_head *head)
List.h (serverframework\include):static inline void list_add_tail(struct list_head *newe, struct list_head *head)
List.h (serverframework\include):static inline void __list_del(struct list_head *prev, struct list_head *next)
List.h (serverframework\include):static inline void list_del(struct list_head *entry)
List.h (serverframework\include):static inline void list_del_init(struct list_head *entry)
List.h (serverframework\include):static inline void list_move(struct list_head *list, struct list_head *head)
List.h (serverframework\include):static inline void list_move_tail(struct list_head *list,
List.h (serverframework\include):				  struct list_head *head)
List.h (serverframework\include):static inline int list_empty(struct list_head *head)
List.h (serverframework\include):static inline void __list_splice(struct list_head *list,
List.h (serverframework\include):				 struct list_head *head)
List.h (serverframework\include):    struct list_head *first = list->next;
List.h (serverframework\include):    struct list_head *last = list->prev;
List.h (serverframework\include):    struct list_head *at = head->next;
List.h (serverframework\include):static inline void list_splice(struct list_head *list, struct list_head *head)
List.h (serverframework\include):static inline void list_splice_init(struct list_head *list,
List.h (serverframework\include):				    struct list_head *head)
List.h (serverframework\include): * list_entry - get the struct for this entry
List.h (serverframework\include): * @ptr:	the &struct list_head pointer.
List.h (serverframework\include): * @type:	the type of the struct this is embedded in.
List.h (serverframework\include): * @member:	the name of the list_struct within the struct.
List.h (serverframework\include): * @pos:	the &struct list_head to use as a loop counter.
List.h (serverframework\include): * @pos:	the &struct list_head to use as a loop counter.
List.h (serverframework\include): * @pos:	the &struct list_head to use as a loop counter.
List.h (serverframework\include): * @n:		another &struct list_head to use as temporary storage
List.h (serverframework\include): * @member:	the name of the list_struct within the struct.
Load.cpp (serverframework\src\base):    struct timeval now;
Load.cpp (serverframework\src\base):    struct timeval now;
Load.cpp (serverframework\src\base):int CLoad::peek_load(struct timeval* nowtime)
Load.cpp (serverframework\src\base):        struct timeval now;
Load.h (serverframework\include):    int peek_load(struct timeval* nowtime = NULL);
Loadtable.cpp (serverframework\src\base):#include <string.h>
Loadtable.cpp (serverframework\src\base):typedef struct tagBlockHeader
Loadtable.cpp (serverframework\src\base):    strncpy(header.key_,key,MAX_KEY_LEN);
Loadtable.cpp (serverframework\src\base):        if(strcmp((const char *) header.key_,key) == 0 
Loadtable.h (serverframework\include):#include <string>
Loadtable.h (serverframework\include):typedef struct tagItemInfo
Loadtable.h (serverframework\include):typedef  std::map<std::string,ItemInfo> MapItems;
Lock.cpp (libcomm\src\lock):#include <string.h>
Lock.cpp (libcomm\src\lock):    struct sembuf op;
Lock.cpp (libcomm\src\lock):    struct sembuf op;
Lock.h (libcomm\include):    struct semid_ds *buf;		//<= buffer for IPC_STAT & IPC_SET
Lock.h (libcomm\include):    struct seminfo *__buf;		//<= buffer for IPC_INFO
Lock.h (libcomm\include):    ~CThreadLock(){pthread_mutex_destroy( &mutex_ );}
Lock.hpp (libcomm\include):			struct sembuf sops;
Lock.hpp (libcomm\include):					printf("%s lock EINTR : %d,%d,%d,%s\n",__FUNCTION__,ret,_semid,errno,strerror(errno));
Lock.hpp (libcomm\include):					printf("%s lock fail : %d,%d,%d,%s\n",__FUNCTION__,ret,_semid,errno,strerror(errno));
Lock.hpp (libcomm\include):			struct sembuf sops;
Lock.hpp (libcomm\include):					printf("%s unlock EINTR : %d,%d,%d,%s\n",__FUNCTION__,ret,_semid,errno,strerror(errno));
Lock.hpp (libcomm\include):					printf("%s unlock fail : %d,%d,%d,%s\n",__FUNCTION__,ret,_semid,errno,strerror(errno));
Log.cpp (libcomm\src\log):#include <string.h>
Log.cpp (libcomm\src\log):    struct tm tmm;
Log.cpp (libcomm\src\log):    static char* level_str[] = {"TRACE", "DEBUG", "NORMAL", "ERROR", "FATAL"}; 
Log.cpp (libcomm\src\log):    SPRINT(buffer_, buff_len, "[%-6s]", level_str[level]);
Log.cpp (libcomm\src\log):    char timestr[64] = {0};
Log.cpp (libcomm\src\log):    struct tm tmm;
Log.cpp (libcomm\src\log):    sprintf(timestr, "%04d%02d%02d%02d%02d%02d", tmm.tm_year + 1900, tmm.tm_mon + 1, tmm.tm_mday, tmm.tm_hour, tmm.tm_min, tmm.tm_sec);
Log.cpp (libcomm\src\log):        timestr[8] = '.';
Log.cpp (libcomm\src\log):        timestr[9] = 0;
Log.cpp (libcomm\src\log):        timestr[10] = '.';
Log.cpp (libcomm\src\log):        timestr[11] = 0;
Log.cpp (libcomm\src\log):        timestr[0] = 0;    
Log.cpp (libcomm\src\log):        sprintf(filepath, "%s/%s.%slog", log_path_, name_prefix_, timestr);
Log.cpp (libcomm\src\log):            strcpy(filename, filepath + strlen(log_path_) + 1);
Log.cpp (libcomm\src\log):    struct stat sb;
Log.cpp (libcomm\src\log):    struct tm cur_tm;
Log.cpp (libcomm\src\log):    struct tm pre_tm;
Log.cpp (libcomm\src\log):    struct stat st;
Log.cpp (libcomm\src\log):    struct stat st2;
Log.cpp (libcomm\src\log):    strncpy(name_prefix_, name_prefix, MAX_PATH_LEN - 1);
Log.cpp (libcomm\src\log):    strncpy(log_path_, log_path, MAX_PATH_LEN - 1);
Log.cpp (libcomm\src\log):    int pathlen = strlen(log_path_);
Log.cpp (libcomm\src\log):    struct sembuf op;
Log.cpp (libcomm\src\log):    struct sembuf op;
Log.h (libcomm\include):    struct semid_ds *buf;		//<= buffer for IPC_STAT & IPC_SET
Log.h (libcomm\include):    struct seminfo *__buf;		//<= buffer for IPC_INFO
Main.cpp (serverframework\src\timer_mgr):#include <string.h>
Main.cpp (serverframework\src\timer_mgr):struct time_mgr
Main.cpp (serverframework\src\timer_mgr):    struct timeval  tval;
Main.cpp (serverframework\src\timer_mgr):    struct tm tmm;
Main.cpp (serverframework\src\timer_mgr):    struct time_mgr* ptm_mgr = (struct time_mgr*)  map_file("./time_mgrtask",sizeof(struct time_mgr), f_new);
MarkupSTL.cpp (libcomm\src\base):	m_strDoc = markup.m_strDoc;
MarkupSTL.cpp (libcomm\src\base):		m_strDoc = szDoc;
MarkupSTL.cpp (libcomm\src\base):		m_strDoc.erase();
MarkupSTL.cpp (libcomm\src\base):	uint32_t nStartSize = m_strDoc.size() / 64 + 8;
MarkupSTL.cpp (libcomm\src\base):	if ( m_strDoc.size() )
MarkupSTL.cpp (libcomm\src\base):		// Load string
MarkupSTL.cpp (libcomm\src\base):		// Save string
MarkupSTL.cpp (libcomm\src\base):		int nFileLen = m_strDoc.size();
MarkupSTL.cpp (libcomm\src\base):		else if ( fwrite( m_strDoc.c_str(), nFileLen, 1, fp ) == 1 )
MarkupSTL.cpp (libcomm\src\base):	TokenPos token( m_strDoc.c_str() );
MarkupSTL.cpp (libcomm\src\base):string CMarkupSTL::GetTagName() const
MarkupSTL.cpp (libcomm\src\base):	string strTagName;
MarkupSTL.cpp (libcomm\src\base):		case MNT_PROCESSING_INSTRUCTION:
MarkupSTL.cpp (libcomm\src\base):				// Processing instruction returns target
MarkupSTL.cpp (libcomm\src\base):				TokenPos token( m_strDoc.c_str() );
MarkupSTL.cpp (libcomm\src\base):					strTagName = x_GetToken( token );
MarkupSTL.cpp (libcomm\src\base):			strTagName = "#comment";
MarkupSTL.cpp (libcomm\src\base):			strTagName = "#cdata-section";
MarkupSTL.cpp (libcomm\src\base):				TokenPos token( m_strDoc.c_str() );
MarkupSTL.cpp (libcomm\src\base):					strTagName = x_GetToken( token );
MarkupSTL.cpp (libcomm\src\base):			strTagName = "#text";
MarkupSTL.cpp (libcomm\src\base):		return strTagName;
MarkupSTL.cpp (libcomm\src\base):		strTagName = x_GetTagName( m_iPos );
MarkupSTL.cpp (libcomm\src\base):	return strTagName;
MarkupSTL.cpp (libcomm\src\base):string CMarkupSTL::GetAttribName( int n ) const
MarkupSTL.cpp (libcomm\src\base):	TokenPos token( m_strDoc.c_str() );
MarkupSTL.cpp (libcomm\src\base):	// Return substring of document
MarkupSTL.cpp (libcomm\src\base):		string strPosName = szPosName;
MarkupSTL.cpp (libcomm\src\base):		m_mapSavedPos[strPosName] = savedpos;
MarkupSTL.cpp (libcomm\src\base):		string strPosName = szPosName;
MarkupSTL.cpp (libcomm\src\base):		mapSavedPosT::const_iterator iterSavePos = m_mapSavedPos.find( strPosName );
MarkupSTL.cpp (libcomm\src\base):string CMarkupSTL::GetChildSubDoc() const
MarkupSTL.cpp (libcomm\src\base):		TokenPos token( m_strDoc.c_str() );
MarkupSTL.cpp (libcomm\src\base):		if ( ! x_FindToken(token) || m_strDoc[token.nL] == '<' )
MarkupSTL.cpp (libcomm\src\base):		return m_strDoc.substr( nL, nR - nL );
MarkupSTL.cpp (libcomm\src\base):string CMarkupSTL::FindGetData( const char* szName )
MarkupSTL.cpp (libcomm\src\base):string CMarkupSTL::EncodeBase64( const unsigned char* pBuffer, int nBufferLen )
MarkupSTL.cpp (libcomm\src\base):	// Return Base64 string
MarkupSTL.cpp (libcomm\src\base):	string strBase64;
MarkupSTL.cpp (libcomm\src\base):	strBase64.resize( nLenBase64 );
MarkupSTL.cpp (libcomm\src\base):	strBase64[nOffsetBase64++] = '\r';
MarkupSTL.cpp (libcomm\src\base):	strBase64[nOffsetBase64++] = '\n';
MarkupSTL.cpp (libcomm\src\base):		// Fill strBase64
MarkupSTL.cpp (libcomm\src\base):				strBase64[nTop] = pCodes[n3BufferBytes & 0x3f];
MarkupSTL.cpp (libcomm\src\base):				strBase64[nTop] = '=';
MarkupSTL.cpp (libcomm\src\base):			strBase64[nOffsetBase64++] = '\r';
MarkupSTL.cpp (libcomm\src\base):			strBase64[nOffsetBase64++] = '\n';
MarkupSTL.cpp (libcomm\src\base):	strBase64.resize( nOffsetBase64 );
MarkupSTL.cpp (libcomm\src\base):	return strBase64;
MarkupSTL.cpp (libcomm\src\base):int CMarkupSTL::DecodeBase64( const string& strBase64, unsigned char* pBuffer, int nBufferLen )
MarkupSTL.cpp (libcomm\src\base):	int nLenBase64 = strBase64.size();
MarkupSTL.cpp (libcomm\src\base):	const unsigned char* pBase64 = (const unsigned char*)strBase64.c_str();
MarkupSTL.cpp (libcomm\src\base):		m_strError = szFormat;
MarkupSTL.cpp (libcomm\src\base):		m_strError = szError;
MarkupSTL.cpp (libcomm\src\base):	TokenPos token( m_strDoc.c_str() );
MarkupSTL.cpp (libcomm\src\base):	string strName;
MarkupSTL.cpp (libcomm\src\base):	while ( strName.empty() )
MarkupSTL.cpp (libcomm\src\base):			if ( token.bIsString )
MarkupSTL.cpp (libcomm\src\base):			char cFirstChar = m_strDoc[token.nL];
MarkupSTL.cpp (libcomm\src\base):				strName = x_GetToken( token );
MarkupSTL.cpp (libcomm\src\base):	if ( m_strDoc[m_aPos[iPos].nStartR-1] == '/' )
MarkupSTL.cpp (libcomm\src\base):			return x_ParseError( "End tag of %s element not found", strName.c_str() );
MarkupSTL.cpp (libcomm\src\base):			if ( ! token.bIsString )
MarkupSTL.cpp (libcomm\src\base):				if ( nTokenCount == 1 && m_strDoc[token.nL] != '/' )
MarkupSTL.cpp (libcomm\src\base):					return x_ParseError( "Expecting end tag of element %s", strName.c_str() );
MarkupSTL.cpp (libcomm\src\base):				else if ( nTokenCount == 2 && ! token.Match(strName.c_str()) )
MarkupSTL.cpp (libcomm\src\base):					return x_ParseError( "End tag does not correspond to %s", strName.c_str() );
MarkupSTL.cpp (libcomm\src\base):				else if ( m_strDoc[token.nL] == '>' )
MarkupSTL.cpp (libcomm\src\base):			return x_ParseError( "End tag not completed for element %s", strName.c_str() );
MarkupSTL.cpp (libcomm\src\base):	token.bIsString = false;
MarkupSTL.cpp (libcomm\src\base):	while ( szDoc[nChar] && strchr(" \t\n\r",szDoc[nChar]) )
MarkupSTL.cpp (libcomm\src\base):		token.bIsString = true;
MarkupSTL.cpp (libcomm\src\base):		while ( szDoc[nChar] && ! strchr(" \t\n\r<>=\\/?!",szDoc[nChar]) )
MarkupSTL.cpp (libcomm\src\base):string CMarkupSTL::x_GetToken( const CMarkupSTL::TokenPos& token ) const
MarkupSTL.cpp (libcomm\src\base):	// The token contains indexes into the document identifying a small substring
MarkupSTL.cpp (libcomm\src\base):	// Build the substring from those indexes and return it
MarkupSTL.cpp (libcomm\src\base):	return m_strDoc.substr( token.nL, (token.nR - token.nL + (((uint32_t)(token.nR)<m_strDoc.size())? 1:0)) );
MarkupSTL.cpp (libcomm\src\base):	TokenPos token( m_strDoc.c_str() );
MarkupSTL.cpp (libcomm\src\base):	TokenPos token( m_strDoc.c_str() );
MarkupSTL.cpp (libcomm\src\base):		// <?target ...?> processing instruction
MarkupSTL.cpp (libcomm\src\base):			nTypeFound = MNT_PROCESSING_INSTRUCTION; // processing instruction
MarkupSTL.cpp (libcomm\src\base):				// Document type requires tokenizing because of strings and brackets
MarkupSTL.cpp (libcomm\src\base):					if ( ! token.bIsString )
MarkupSTL.cpp (libcomm\src\base):			const char* pEnd = strstr( &szDoc[token.nNext], szEndOfNode );
MarkupSTL.cpp (libcomm\src\base):			token.nNext = (pEnd - szDoc) + strlen(szEndOfNode);
MarkupSTL.cpp (libcomm\src\base):string CMarkupSTL::x_GetTagName( int iPos ) const
MarkupSTL.cpp (libcomm\src\base):	TokenPos token( m_strDoc.c_str() );
MarkupSTL.cpp (libcomm\src\base):	// Return substring of document
MarkupSTL.cpp (libcomm\src\base):		if ( ! token.bIsString )
MarkupSTL.cpp (libcomm\src\base):			if ( m_strDoc[token.nL] == '>' || m_strDoc[token.nL] == '/' )
MarkupSTL.cpp (libcomm\src\base):			if ( m_strDoc[token.nL] == '=' )
MarkupSTL.cpp (libcomm\src\base):string CMarkupSTL::x_GetAttrib( int iPos, const char* szAttrib ) const
MarkupSTL.cpp (libcomm\src\base):	TokenPos token( m_strDoc.c_str() );
MarkupSTL.cpp (libcomm\src\base):		return x_TextFromDoc( token.nL, token.nR - (((uint32_t)(token.nR)<m_strDoc.size())?0:1) );
MarkupSTL.cpp (libcomm\src\base):	// Convert integer to string and call SetChildAttrib
MarkupSTL.cpp (libcomm\src\base):	TokenPos token( m_strDoc.c_str() );
MarkupSTL.cpp (libcomm\src\base):	string strInsert;
MarkupSTL.cpp (libcomm\src\base):		strInsert = x_TextToDoc( szValue, true );
MarkupSTL.cpp (libcomm\src\base):		// Insert string name value pair
MarkupSTL.cpp (libcomm\src\base):		string strFormat;
MarkupSTL.cpp (libcomm\src\base):		strFormat = " ";
MarkupSTL.cpp (libcomm\src\base):		strFormat += szAttrib;
MarkupSTL.cpp (libcomm\src\base):		strFormat += "=\"";
MarkupSTL.cpp (libcomm\src\base):		strFormat += x_TextToDoc( szValue, true );
MarkupSTL.cpp (libcomm\src\base):		strFormat += "\"";
MarkupSTL.cpp (libcomm\src\base):		strInsert = strFormat;
MarkupSTL.cpp (libcomm\src\base):	x_DocChange( nInsertAt, nReplace, strInsert );
MarkupSTL.cpp (libcomm\src\base):	int nAdjust = strInsert.size() - nReplace;
MarkupSTL.cpp (libcomm\src\base):		TokenPos token( m_strDoc.c_str() );
MarkupSTL.cpp (libcomm\src\base):				if ( x_FindToken(token) && m_strDoc[token.nL] == '=' && x_FindToken(token) && token.bIsString )
MarkupSTL.cpp (libcomm\src\base):bool CMarkupSTL::x_CreateNode( string& strNode, int nNodeType, const char* szText )
MarkupSTL.cpp (libcomm\src\base):	// Set strNode based on nNodeType and szText
MarkupSTL.cpp (libcomm\src\base):		if ( strstr(szText,"]]>") != NULL )
MarkupSTL.cpp (libcomm\src\base):		strNode = "<![CDATA[";
MarkupSTL.cpp (libcomm\src\base):		strNode += szText;
MarkupSTL.cpp (libcomm\src\base):		strNode += "]]>";
MarkupSTL.cpp (libcomm\src\base):	case MNT_PROCESSING_INSTRUCTION:
MarkupSTL.cpp (libcomm\src\base):		strNode = "<?";
MarkupSTL.cpp (libcomm\src\base):		strNode += szText;
MarkupSTL.cpp (libcomm\src\base):		strNode += "?>";
MarkupSTL.cpp (libcomm\src\base):		strNode = "<!--";
MarkupSTL.cpp (libcomm\src\base):		strNode += szText;
MarkupSTL.cpp (libcomm\src\base):		strNode += "-->";
MarkupSTL.cpp (libcomm\src\base):		strNode = "<";
MarkupSTL.cpp (libcomm\src\base):		strNode += szText;
MarkupSTL.cpp (libcomm\src\base):		strNode += "/>";
MarkupSTL.cpp (libcomm\src\base):		strNode = x_TextToDoc( szText );
MarkupSTL.cpp (libcomm\src\base):		strNode = szText;
MarkupSTL.cpp (libcomm\src\base):	string strInsert;
MarkupSTL.cpp (libcomm\src\base):		if ( ! x_CreateNode(strInsert, m_nNodeType, szData) )
MarkupSTL.cpp (libcomm\src\base):		x_DocChange( m_nNodeOffset, m_nNodeLength, strInsert );
MarkupSTL.cpp (libcomm\src\base):		x_AdjustForNode( m_iPosParent, iPos, strInsert.size() - m_nNodeLength );
MarkupSTL.cpp (libcomm\src\base):		m_nNodeLength = strInsert.size();
MarkupSTL.cpp (libcomm\src\base):	// Build strInsert from szData based on nCDATA
MarkupSTL.cpp (libcomm\src\base):		if ( ! x_CreateNode(strInsert, MNT_CDATA_SECTION, szData) )
MarkupSTL.cpp (libcomm\src\base):		strInsert = x_TextToDoc( szData );
MarkupSTL.cpp (libcomm\src\base):		string strTagName = x_GetTagName( iPos );
MarkupSTL.cpp (libcomm\src\base):		m_aPos[iPos].nEndL -= (1 + strTagName.size());
MarkupSTL.cpp (libcomm\src\base):		string strFormat;
MarkupSTL.cpp (libcomm\src\base):		strFormat = ">";
MarkupSTL.cpp (libcomm\src\base):		strFormat += strInsert;
MarkupSTL.cpp (libcomm\src\base):		strFormat += "</";
MarkupSTL.cpp (libcomm\src\base):		strFormat += strTagName;
MarkupSTL.cpp (libcomm\src\base):		strInsert = strFormat;
MarkupSTL.cpp (libcomm\src\base):	x_DocChange( nInsertAt, nReplace, strInsert );
MarkupSTL.cpp (libcomm\src\base):	int nAdjust = strInsert.size() - nReplace;
MarkupSTL.cpp (libcomm\src\base):string CMarkupSTL::x_GetData( int iPos ) const
MarkupSTL.cpp (libcomm\src\base):			return m_strDoc.substr( m_nNodeOffset+4, m_nNodeLength-7 );
MarkupSTL.cpp (libcomm\src\base):		else if ( m_nNodeType == MNT_PROCESSING_INSTRUCTION )
MarkupSTL.cpp (libcomm\src\base):			return m_strDoc.substr( m_nNodeOffset+2, m_nNodeLength-4 );
MarkupSTL.cpp (libcomm\src\base):			return m_strDoc.substr( m_nNodeOffset+8, m_nNodeLength-11 );
MarkupSTL.cpp (libcomm\src\base):			return m_strDoc.substr( m_nNodeOffset, m_nNodeLength );
MarkupSTL.cpp (libcomm\src\base):	// Return a string representing data between start and end tag
MarkupSTL.cpp (libcomm\src\base):	// Return empty string if there are any children elements
MarkupSTL.cpp (libcomm\src\base):		TokenPos token( m_strDoc.c_str() );
MarkupSTL.cpp (libcomm\src\base):		if ( x_FindToken( token ) && m_strDoc[token.nL] == '<'
MarkupSTL.cpp (libcomm\src\base):				&& strncmp( &token.szDoc[token.nL+1], "![CDATA[", 8 ) == 0 )
MarkupSTL.cpp (libcomm\src\base):			int nEndCDATA = m_strDoc.find( "]]>", token.nNext );
MarkupSTL.cpp (libcomm\src\base):			if ( nEndCDATA != (int32_t)(string::npos) && nEndCDATA < m_aPos[iPos].nEndL )
MarkupSTL.cpp (libcomm\src\base):				return m_strDoc.substr( token.nL+9, nEndCDATA-token.nL-9 );
MarkupSTL.cpp (libcomm\src\base):string CMarkupSTL::x_TextToDoc( const char* szText, bool bAttrib ) const
MarkupSTL.cpp (libcomm\src\base):	// &apos; apostrophe or single quote
MarkupSTL.cpp (libcomm\src\base):	string strResult;
MarkupSTL.cpp (libcomm\src\base):	int nLen = strlen( szText );
MarkupSTL.cpp (libcomm\src\base):	strResult.reserve( nLen + nLen / 10 );
MarkupSTL.cpp (libcomm\src\base):		if ( (pFound=strchr(pFind,cSource)) != NULL )
MarkupSTL.cpp (libcomm\src\base):			strResult.append(pFound);
MarkupSTL.cpp (libcomm\src\base):			strResult += cSource;
MarkupSTL.cpp (libcomm\src\base):	return strResult;
MarkupSTL.cpp (libcomm\src\base):string CMarkupSTL::x_TextFromDoc( int nLeft, int nRight ) const
MarkupSTL.cpp (libcomm\src\base):	string strResult;
MarkupSTL.cpp (libcomm\src\base):	strResult.reserve( nRight - nLeft + 1 );
MarkupSTL.cpp (libcomm\src\base):	const char* pSource = m_strDoc.c_str();
MarkupSTL.cpp (libcomm\src\base):					&& strncmp(szaCode[nMatch],&pSource[nChar+1],anCodeLen[nMatch]) == 0 )
MarkupSTL.cpp (libcomm\src\base):		strResult += cSource;
MarkupSTL.cpp (libcomm\src\base):	return strResult;
MarkupSTL.cpp (libcomm\src\base):void CMarkupSTL::x_DocChange( int nLeft, int nReplace, const string& strInsert )
MarkupSTL.cpp (libcomm\src\base):	// Insert strInsert int m_strDoc at nLeft replacing nReplace chars
MarkupSTL.cpp (libcomm\src\base):	// When creating a document, reduce reallocs by reserving string space
MarkupSTL.cpp (libcomm\src\base):	int nNewLength = strInsert.size() + m_strDoc.size() - nReplace;
MarkupSTL.cpp (libcomm\src\base):	int nAllocLen = m_strDoc.capacity();
MarkupSTL.cpp (libcomm\src\base):		m_strDoc.reserve( nReserve );
MarkupSTL.cpp (libcomm\src\base):	m_strDoc.replace( nLeft, nReplace, strInsert);
MarkupSTL.cpp (libcomm\src\base):		TokenPos token( m_strDoc.c_str() );
MarkupSTL.cpp (libcomm\src\base):		if ( ! x_FindToken(token) || m_strDoc[token.nL] == '<' )
MarkupSTL.cpp (libcomm\src\base):		if ( m_strDoc.IsEmpty() )
MarkupSTL.cpp (libcomm\src\base):			m_strDoc = x_VERSIONTAG;
MarkupSTL.cpp (libcomm\src\base):		m_aPos[0].nEndL = m_strDoc.size();
MarkupSTL.cpp (libcomm\src\base):	// Create string for insert
MarkupSTL.cpp (libcomm\src\base):	string strInsert;
MarkupSTL.cpp (libcomm\src\base):	int nLenName = strlen(szName);
MarkupSTL.cpp (libcomm\src\base):	int nLenValue = szValue? strlen(szValue) : 0;
MarkupSTL.cpp (libcomm\src\base):		strInsert = "<";
MarkupSTL.cpp (libcomm\src\base):		strInsert += szName;
MarkupSTL.cpp (libcomm\src\base):		strInsert += "/>\r\n";
MarkupSTL.cpp (libcomm\src\base):		string strValue = x_TextToDoc( szValue );
MarkupSTL.cpp (libcomm\src\base):		nLenValue = strValue.size();
MarkupSTL.cpp (libcomm\src\base):		strInsert = "<";
MarkupSTL.cpp (libcomm\src\base):		strInsert += szName;
MarkupSTL.cpp (libcomm\src\base):		strInsert += ">";
MarkupSTL.cpp (libcomm\src\base):		strInsert += strValue;
MarkupSTL.cpp (libcomm\src\base):		strInsert += "</";
MarkupSTL.cpp (libcomm\src\base):		strInsert += szName;
MarkupSTL.cpp (libcomm\src\base):		strInsert += ">\r\n";
MarkupSTL.cpp (libcomm\src\base):		string strParentTagName = x_GetTagName(iPosParent);
MarkupSTL.cpp (libcomm\src\base):		string strFormat;
MarkupSTL.cpp (libcomm\src\base):		strFormat = ">\r\n";
MarkupSTL.cpp (libcomm\src\base):		strFormat += strInsert;
MarkupSTL.cpp (libcomm\src\base):		strFormat += "</";
MarkupSTL.cpp (libcomm\src\base):		strFormat += strParentTagName;
MarkupSTL.cpp (libcomm\src\base):		strInsert = strFormat;
MarkupSTL.cpp (libcomm\src\base):		m_aPos[iPosParent].nEndL -= (strParentTagName.size() + 1);
MarkupSTL.cpp (libcomm\src\base):	x_DocChange( nLeft, nReplace, strInsert );
MarkupSTL.cpp (libcomm\src\base):	x_Adjust( iPos, strInsert.size() - nReplace );
MarkupSTL.cpp (libcomm\src\base):	string strInsert = token.szDoc;
MarkupSTL.cpp (libcomm\src\base):	string strParentTagName;
MarkupSTL.cpp (libcomm\src\base):		strParentTagName = x_GetTagName(iPosParent);
MarkupSTL.cpp (libcomm\src\base):		string strFormat;
MarkupSTL.cpp (libcomm\src\base):		strFormat = ">\r\n";
MarkupSTL.cpp (libcomm\src\base):		strFormat += strInsert;
MarkupSTL.cpp (libcomm\src\base):		strFormat += "</";
MarkupSTL.cpp (libcomm\src\base):		strFormat += strParentTagName;
MarkupSTL.cpp (libcomm\src\base):		strInsert = strFormat;
MarkupSTL.cpp (libcomm\src\base):	x_DocChange( nLeft, nReplace, strInsert );
MarkupSTL.cpp (libcomm\src\base):		string strRevert = bEmptyParent?"/":"";
MarkupSTL.cpp (libcomm\src\base):		x_DocChange( nLeft, strInsert.size(), strRevert );
MarkupSTL.cpp (libcomm\src\base):			m_aPos[iPosParent].nEndL -= (strParentTagName.size() + 1);
MarkupSTL.cpp (libcomm\src\base):		x_Adjust( iPos, strInsert.size() - nReplace, true );
MarkupSTL.cpp (libcomm\src\base):	TokenPos token( m_strDoc.c_str() );
MarkupSTL.cpp (libcomm\src\base):	x_DocChange( m_aPos[iPos].nStartL, nLen, string() );
MarkupSTL.cpp (libcomm\src\base):	string strInsert;
MarkupSTL.cpp (libcomm\src\base):	if ( ! x_CreateNode(strInsert, nNodeType, szText) )
MarkupSTL.cpp (libcomm\src\base):	// Only comments, DTDs, and processing instructions are followed by CRLF
MarkupSTL.cpp (libcomm\src\base):	if ( nNodeType == MNT_PROCESSING_INSTRUCTION
MarkupSTL.cpp (libcomm\src\base):	nNodeLength = strInsert.size();
MarkupSTL.cpp (libcomm\src\base):		strInsert += "\r\n";
MarkupSTL.cpp (libcomm\src\base):		string strParentTagName = x_GetTagName(iPosParent);
MarkupSTL.cpp (libcomm\src\base):		string strFormat;
MarkupSTL.cpp (libcomm\src\base):		strFormat = ">";
MarkupSTL.cpp (libcomm\src\base):			strFormat += "\r\n";
MarkupSTL.cpp (libcomm\src\base):		strFormat += strInsert;
MarkupSTL.cpp (libcomm\src\base):		strFormat += "</";
MarkupSTL.cpp (libcomm\src\base):		strFormat += strParentTagName;
MarkupSTL.cpp (libcomm\src\base):		strInsert = strFormat;
MarkupSTL.cpp (libcomm\src\base):		m_aPos[iPosParent].nEndL -= (strParentTagName.size() + 1);
MarkupSTL.cpp (libcomm\src\base):	x_DocChange( nInsertAt, nReplace, strInsert );
MarkupSTL.cpp (libcomm\src\base):	x_AdjustForNode( iPosParent, iPos, strInsert.size() - nReplace );
MarkupSTL.cpp (libcomm\src\base):	TokenPos token( m_strDoc.c_str() );
MarkupSTL.cpp (libcomm\src\base): 	x_DocChange( nNodeOffset, nNodeLength, string() );
MarkupSTL.h (libcomm\include):#include <string>
MarkupSTL.h (libcomm\include):#define _DS(i) (i?&(m_strDoc.c_str())[m_aPos[i].nStartL]:0)
MarkupSTL.h (libcomm\include):	std::string GetTagName() const;
MarkupSTL.h (libcomm\include):	std::string GetChildTagName() const { return x_GetTagName(m_iPosChild); };
MarkupSTL.h (libcomm\include):	std::string GetData() const { return x_GetData(m_iPos); };
MarkupSTL.h (libcomm\include):	std::string GetChildData() const { return x_GetData(m_iPosChild); };
MarkupSTL.h (libcomm\include):	std::string FindGetData( const char* szName );
MarkupSTL.h (libcomm\include):	std::string GetAttrib( const char* szAttrib ) const { return x_GetAttrib(m_iPos,szAttrib); };
MarkupSTL.h (libcomm\include):	std::string GetChildAttrib( const char* szAttrib ) const { return x_GetAttrib(m_iPosChild,szAttrib); };
MarkupSTL.h (libcomm\include):	std::string GetAttribName( int n ) const;
MarkupSTL.h (libcomm\include):	std::string GetError() const { return m_strError; };
MarkupSTL.h (libcomm\include):		MNT_PROCESSING_INSTRUCTION	= 16, // 0x10
MarkupSTL.h (libcomm\include):	std::string GetDoc() const { return m_strDoc; };
MarkupSTL.h (libcomm\include):	std::string GetChildSubDoc() const;
MarkupSTL.h (libcomm\include):	static std::string EncodeBase64( const unsigned char* pBuffer, int nBufferLen );
MarkupSTL.h (libcomm\include):	static int DecodeBase64( const std::string& strBase64, unsigned char* pBuffer, int nBufferLen );
MarkupSTL.h (libcomm\include):	std::string m_strDoc;
MarkupSTL.h (libcomm\include):	std::string m_strError;
MarkupSTL.h (libcomm\include):	struct ElemPos
MarkupSTL.h (libcomm\include):	struct TokenPos
MarkupSTL.h (libcomm\include):		void Clear() { nL=0; nR=-1; nNext=0; bIsString=false; };
MarkupSTL.h (libcomm\include):			return ( (strnicmp( &szDoc[nL], szName, nLen ) == 0)
MarkupSTL.h (libcomm\include):			return ( (strncmp( &szDoc[nL], szName, nLen ) == 0)
MarkupSTL.h (libcomm\include):				&& ( szName[nLen] == '\0' || strchr(" =/[",szName[nLen]) ) );
MarkupSTL.h (libcomm\include):		bool bIsString;
MarkupSTL.h (libcomm\include):	struct SavedPos
MarkupSTL.h (libcomm\include):	typedef std::map<std::string,SavedPos> mapSavedPosT;
MarkupSTL.h (libcomm\include):	std::string x_GetToken( const TokenPos& token ) const;
MarkupSTL.h (libcomm\include):	std::string x_GetTagName( int iPos ) const;
MarkupSTL.h (libcomm\include):	std::string x_GetData( int iPos ) const;
MarkupSTL.h (libcomm\include):	std::string x_GetAttrib( int iPos, const char* szAttrib ) const;
MarkupSTL.h (libcomm\include):	bool x_CreateNode( std::string& strNode, int nNodeType, const char* szText );
MarkupSTL.h (libcomm\include):	void x_DocChange( int nLeft, int nReplace, const std::string& strInsert );
MarkupSTL.h (libcomm\include):	std::string x_TextToDoc( const char* szText, bool bAttrib = false ) const;
MarkupSTL.h (libcomm\include):	std::string x_TextFromDoc( int nLeft, int nRight ) const;
Md5.cpp (libcomm\src\util):string MD5Sum_test::toString()
Md5.cpp (libcomm\src\util):	return toString(m_md5);
Md5.cpp (libcomm\src\util):string MD5Sum_test::toTempString()
Md5.cpp (libcomm\src\util):	string result = toString();
Md5.cpp (libcomm\src\util):string MD5Sum_test::toString(const unsigned char* md5)
Md5.cpp (libcomm\src\util):bool getFileMd5Value(const char *fileName,std::string &md5Ret)
Md5.cpp (libcomm\src\util):	md5Ret = md5.toString();
Md5.cpp (libcomm\src\util):string getStringMD5Value(const char *str)
Md5.cpp (libcomm\src\util):	md5.put(str,strlen(str));
Md5.cpp (libcomm\src\util):	return md5.toString();
Md5.cpp (libcomm\src\util):	string md5sum = getStringMD5Value(argv[1]);
Md5.cpp (libcomm\src\util):	printf("Md5sum=%s\n", md5sum.c_str());
Md5.cpp (libcomm\src\util):	Md5Sum(r, argv[1], strlen(argv[1]));
Md5.h (libcomm\include):#include <string>
Md5.h (libcomm\include):#include <fstream>
Md5.h (libcomm\include):    std::string toString();
Md5.h (libcomm\include):    std::string toTempString();
Md5.h (libcomm\include):    static std::string toString(const unsigned char* md5);
Md5.h (libcomm\include):bool getFileMd5Value(const char *fileName,std::string &md5Ret);
Md5.h (libcomm\include):std::string getStringMD5Value(const char *str);
Mempool.cpp (serverframework\src\base):#include <iostream>
Misc.cpp (libcomm\src\base):#include <string.h>
Misc.cpp (libcomm\src\base):struct time_mgr
Misc.cpp (libcomm\src\base):    struct timeval  tval;
Misc.cpp (libcomm\src\base):    struct tm tmm;
Misc.cpp (libcomm\src\base):    struct time_mgr* ptm_mgr = (struct time_mgr*)  map_file("./time_mgrtask",sizeof(struct time_mgr), f_new);
Misc.cpp (libcomm\src\base):    static  struct time_mgr* ptm_mgr = (struct time_mgr*)  map_file(tmfile,sizeof(struct time_mgr), f_new);
Misc.cpp (libcomm\src\base):void get_timeofday(struct timeval* pval,const char* tmfile)
Misc.cpp (libcomm\src\base):    static  struct time_mgr* ptm_mgr = (struct time_mgr*)  map_file(tmfile,sizeof(struct time_mgr), f_new);   
Misc.cpp (libcomm\src\base):    struct ifreq buf[10];
Misc.cpp (libcomm\src\base):    struct ifconf ifc;
Misc.cpp (libcomm\src\base):            intrface = ifc.ifc_len / sizeof(struct ifreq);
Misc.cpp (libcomm\src\base):                if(strcmp(buf[intrface].ifr_name, ifname) == 0)
Misc.cpp (libcomm\src\base):                        ip = (unsigned)((struct sockaddr_in *)(&buf[intrface].ifr_addr))->sin_addr.s_addr;
Misc.cpp (libcomm\src\base):unsigned CMisc::getdelay(const struct timeval& begin)
Misc.cpp (libcomm\src\base):    struct timeval now;
Misc.cpp (libcomm\src\base):    struct mallinfo info = mallinfo();
Misc.h (libcomm\include):void get_timeofday(struct timeval* pval,const char* tmfile="./time_mgrtask");
Misc.h (libcomm\include):struct timeval begin;   \
Misc.h (libcomm\include):    static unsigned getdelay(const struct timeval& begin);
Myepoll.h (serverframework\include): * On x86-64 make the 64bit structure have the same alignment as the
Myepoll.h (serverframework\include): * 32bit structure. This makes 32bit emulation easier.
Myepoll.h (serverframework\include):struct epoll_event {
Myepoll.h (serverframework\include):static inline _syscall4(int, epoll_ctl, int, epfd, int, op, int, fd, struct epoll_event *, event);
Myepoll.h (serverframework\include):static inline _syscall4(int, epoll_wait, int, epfd, struct epoll_event *, events, int, maxevents, int, timeout);
Myepoll.h (serverframework\include):static inline int epoll_ctl( int epfd, int op, int fd, struct epoll_event * event){
Myepoll.h (serverframework\include):static inline int epoll_wait( int epfd, struct epoll_event * events, int maxevents, int timeout){
Procmon.cpp (serverframework\src\base):#define STAT_LEN_WARNING_STR "\n***stat data too long***\n"
Procmon.cpp (serverframework\src\base):        printf("msgget fail,errno=%d,errmsg=%s\n",errno,strerror(errno));
Procmon.cpp (serverframework\src\base):    conf.Load(common_config_file_.c_str());
Procmon.cpp (serverframework\src\base):    int log_key_base = strtol(conf.GetAttrib("key_base").c_str(),0,0 );
Procmon.cpp (serverframework\src\base):    static char* proc_str[PROCMON_STATUS_OTFMEM<<1] = {"Proc Ok", "Proc O", "Proc S", "Proc OS", "Proc L", "Proc OL", "Proc SL", "Proc OSL", "Proc M", "Proc OM", "Proc SM", "Proc LM", "Proc OSM", "Proc OLM", "Proc SLM", "Proc OSLM"};
Procmon.cpp (serverframework\src\base):    struct tm tmm; 
Procmon.cpp (serverframework\src\base):    int warning_str_len=strlen(STAT_LEN_WARNING_STR)+1;
Procmon.cpp (serverframework\src\base):    ret_len = snprintf(buf + *len,buf_len-*len-warning_str_len,"\nTProcMonStat[%-5d], %04d-%02d-%02d %02d:%02d:%02d\n",          
Procmon.cpp (serverframework\src\base):    if(ret_len>=buf_len-*len-warning_str_len)
Procmon.cpp (serverframework\src\base):            ret_len= snprintf(buf + *len,buf_len-*len-warning_str_len, "%-10s%-5u%-20s%-30s%-5u%-5u%-5u%-5u%-5u%-5u%-5u:%-5u:%-5u\n",
Procmon.cpp (serverframework\src\base):            if(ret_len>=buf_len-*len-warning_str_len)
Procmon.cpp (serverframework\src\base):            ret_len = snprintf(buf + *len,buf_len - *len - warning_str_len,"procstat | pid     | watermark | srate| delay | memused |conn_num |timestamp\n");
Procmon.cpp (serverframework\src\base):            if(ret_len>=buf_len-*len-warning_str_len)
Procmon.cpp (serverframework\src\base):                    ret_len=snprintf(buf + *len,buf_len-*len-warning_str_len, "%-10s%-15u%-8u%-8u%-8u%-8u%-8u%-20s",
Procmon.cpp (serverframework\src\base):                    proc_str[proc->status_], procinfo->procid_, procinfo->watermark_, procinfo->srate_, 
Procmon.cpp (serverframework\src\base):                    if(ret_len>=buf_len-*len-warning_str_len)
Procmon.cpp (serverframework\src\base):            ret_len=snprintf(buf + *len,buf_len-*len-warning_str_len,
Procmon.cpp (serverframework\src\base):            if(ret_len>=buf_len-*len-warning_str_len)
Procmon.cpp (serverframework\src\base):    *len=buf_len-warning_str_len-1;
Procmon.cpp (serverframework\src\base):    *len+=snprintf(buf+*len,warning_str_len,"%s",STAT_LEN_WARNING_STR);
Procmon.cpp (serverframework\src\base):        snprintf(cmd_buf,sizeof(cmd_buf) -1,"%s/%s %s %s/%s %d %d %d %s", basepath, exefile, common_config_file_.c_str(),
Procmon.h (serverframework\include):#include <string.h>
Procmon.h (serverframework\include):typedef struct 
Procmon.h (serverframework\include):typedef struct 
Procmon.h (serverframework\include):typedef struct 
Procmon.h (serverframework\include):typedef struct
Procmon.h (serverframework\include):typedef struct 
Procmon.h (serverframework\include):typedef struct 
Procmon.h (serverframework\include):typedef struct 
Procmon.h (serverframework\include):    string common_config_file_;
Protocol_err.h (libprotocol\include):#include <string>
Protocol_err.h (libprotocol\include):using std::string;
Protocol_err.h (libprotocol\include):	static string GetErrInfo(unsigned int err_code)
Protocol_err.h (libprotocol\include):		hash_map<unsigned int, string>::iterator it = m_ErrInfo.find(err_code);		
Protocol_err.h (libprotocol\include):		 return (it == m_ErrInfo.end()) ? string(""):it->second;
Protocol_err.h (libprotocol\include):	static int RegErrInfo(unsigned int err_code, const string &err_info)
Protocol_err.h (libprotocol\include):	//static __gnu_cxx::hash_map<unsigned int, string> m_ErrInfo;
Protocol_err.h (libprotocol\include):    static hash_map<unsigned int, string> m_ErrInfo;
Protocol_err.h (libprotocol\include):	string err_info = ErrInfoMng::GetErrInfo(ERR_IM_AUTH);
Protocol_pack.cpp (libprotocol\src):const unsigned char STR_END = '\0';
Protocol_pack.cpp (libprotocol\src)://__gnu_cxx::hash_map<unsigned int, string> ErrInfoMng::m_ErrInfo;
Protocol_pack.cpp (libprotocol\src):hash_map<unsigned int, string> ErrInfoMng::m_ErrInfo;
Protocol_pack.cpp (libprotocol\src):	m_oss.str("");
Protocol_pack.cpp (libprotocol\src):    return PackString(data);
Protocol_pack.cpp (libprotocol\src):Packer & Packer::PackString(const string &v)
Protocol_pack.cpp (libprotocol\src):	m_oss<<v<<STR_END;
Protocol_pack.cpp (libprotocol\src):Packer & Packer::PackString(const char *v)
Protocol_pack.cpp (libprotocol\src):    m_oss<<v<<STR_END;
Protocol_pack.cpp (libprotocol\src):string Packer::GetBody()
Protocol_pack.cpp (libprotocol\src):	return m_oss.str();
Protocol_pack.cpp (libprotocol\src):string Packer::GetPack(const MsgHeader &h)
Protocol_pack.cpp (libprotocol\src):        unsigned int body_size = m_oss.str().size();
Protocol_pack.cpp (libprotocol\src):        memcpy(hbuf + MSG_HEADER_LEN, m_oss.str().data(), body_size);
Protocol_pack.cpp (libprotocol\src):        return string(hbuf, pack_len);
Protocol_pack.cpp (libprotocol\src):        unsigned int body_size = m_oss.str().size();
Protocol_pack.cpp (libprotocol\src):        memcpy(hbuf + MSG_HEADER_LEN, m_oss.str().data(), body_size);
Protocol_pack.cpp (libprotocol\src):        string strPack(hbuf, pack_len);
Protocol_pack.cpp (libprotocol\src):        return strPack;
Protocol_pack.cpp (libprotocol\src):string Packer::GetPack(const MsgHeader &h, const void *key, unsigned int key_len)
Protocol_pack.cpp (libprotocol\src):	string body(m_oss.str());
Protocol_pack.cpp (libprotocol\src):	return string(hbuf, pack_len);
Protocol_pack.cpp (libprotocol\src):    string strPack(hbuf, pack_len);    
Protocol_pack.cpp (libprotocol\src):    return strPack;
Protocol_pack.cpp (libprotocol\src):string Packer::GetPack(const MsgHeader & h, unsigned short ck_len,const char * ck)
Protocol_pack.cpp (libprotocol\src):        unsigned int body_size = m_oss.str().size();
Protocol_pack.cpp (libprotocol\src):        memcpy(hbuf + MSG_HEADER_LEN, m_oss.str().data(), body_size);
Protocol_pack.cpp (libprotocol\src):        return string(hbuf, pack_len);
Protocol_pack.cpp (libprotocol\src):        unsigned int body_size = m_oss.str().size();
Protocol_pack.cpp (libprotocol\src):        memcpy(hbuf + MSG_HEADER_LEN, m_oss.str().data(), body_size);
Protocol_pack.cpp (libprotocol\src):        string strPack(hbuf, pack_len);
Protocol_pack.cpp (libprotocol\src):        return strPack;
Protocol_pack.cpp (libprotocol\src):    return PackString(data);
Protocol_pack.cpp (libprotocol\src):FixedPacker & FixedPacker::PackString(const string &v)
Protocol_pack.cpp (libprotocol\src):    *m_pTail = STR_END;
Protocol_pack.cpp (libprotocol\src):FixedPacker & FixedPacker::PackString(const char *v)
Protocol_pack.cpp (libprotocol\src):    int vlen = strlen(v);
Protocol_pack.cpp (libprotocol\src):string FixedPacker::GetBody()
Protocol_pack.cpp (libprotocol\src):	string strBody;
Protocol_pack.cpp (libprotocol\src):	strBody.assign(m_pBuf + MSG_HEADER_LEN,m_pTail - m_pBuf - MSG_HEADER_LEN);
Protocol_pack.cpp (libprotocol\src):	return strBody;
Protocol_pack.cpp (libprotocol\src):    const char *p = this->UnPackString(len);
Protocol_pack.cpp (libprotocol\src):unsigned int UnPacker::UnPackBinary(string &data, unsigned int len)
Protocol_pack.cpp (libprotocol\src):string UnPacker::UnPackString()
Protocol_pack.cpp (libprotocol\src):		return string();
Protocol_pack.cpp (libprotocol\src):	return string(p, q-p);
Protocol_pack.cpp (libprotocol\src):const char *UnPacker::UnPackString(unsigned int &len)
Protocol_pack.h (libprotocol\include):#include <string>
Protocol_pack.h (libprotocol\include):#include <sstream>
Protocol_pack.h (libprotocol\include):using std::string;
Protocol_pack.h (libprotocol\include):using std::ostringstream;
Protocol_pack.h (libprotocol\include):inline int SetCookie(unsigned char * p,unsigned int len,const string & cookie)
Protocol_pack.h (libprotocol\include):inline int GetCookie(const unsigned char *p,string & ck)
Protocol_pack.h (libprotocol\include):	Packer &PackString(const string &v);
Protocol_pack.h (libprotocol\include):	Packer &PackString(const char *v);
Protocol_pack.h (libprotocol\include):	string GetBody();
Protocol_pack.h (libprotocol\include):	string GetPack(const MsgHeader &h);
Protocol_pack.h (libprotocol\include):	string GetPack(const MsgHeader &h, const void *key, unsigned int key_len);
Protocol_pack.h (libprotocol\include):        string GetPack(const MsgHeader & h,unsigned short ck_len,const char * ck);
Protocol_pack.h (libprotocol\include):	ostringstream m_oss;
Protocol_pack.h (libprotocol\include):	FixedPacker &PackString(const string &v);
Protocol_pack.h (libprotocol\include):	FixedPacker &PackString(const char *v);
Protocol_pack.h (libprotocol\include):	string GetBody();
Protocol_pack.h (libprotocol\include):        unsigned int UnPackBinary(string &data, unsigned int len);
Protocol_pack.h (libprotocol\include):	string UnPackString();
Protocol_pack.h (libprotocol\include):	const char *UnPackString(unsigned int &len);
Protocol_pack.h (libprotocol\include):	string m_Body;
Serverbase.cpp (serverframework\src\base):int CContextQueue::AddItem(const string & key,const TContext * context)
Serverbase.cpp (serverframework\src\base):TContext * CContextQueue::GetItem(const string & key, bool bRemove /* = false*/)
Serverbase.cpp (serverframework\src\base):int CContextQueue::GetTimeOutList(std::vector<string> & v)
Serverbase.cpp (serverframework\src\base):struct CServerBase::TInternal
Serverbase.cpp (serverframework\src\base):    char* p = strstr(argv[1], "-");
Serverbase.cpp (serverframework\src\base):        ix_->argv_[i] = strdup(argv[i]);
Serverbase.cpp (serverframework\src\base):    struct rlimit rlim;
Serverbase.cpp (serverframework\src\base):int CServerBase::spp_set_context(const string & key,const TContext * context)
Serverbase.cpp (serverframework\src\base):TContext * CServerBase::spp_get_context(const string & key,bool bRemove)
Serverbase.h (serverframework\include):#include <string>
Serverbase.h (serverframework\include):typedef struct tagTContext
Serverbase.h (serverframework\include):typedef int (*cb_context_timeout_list)(const std::vector<string> & v,void * arg1,void * arg2);
Serverbase.h (serverframework\include):    int AddItem(const string & key,const TContext * context);
Serverbase.h (serverframework\include):    TContext * GetItem(const string & key,bool bRemove = false);
Serverbase.h (serverframework\include):    int GetTimeOutList(std::vector<string> & v);
Serverbase.h (serverframework\include):    typedef std::map<std::string,TContext * > MapContext;
Serverbase.h (serverframework\include):    //virtual int spp_set_context(const string & key,const TContext * context);
Serverbase.h (serverframework\include):    //TContext * spp_get_context(const string & key,bool bRemove);
Serverbase.h (serverframework\include):    virtual void do_timer_callback(const struct timeval & nowtime) = 0;
Serverbase.h (serverframework\include):    struct TInternal;
Serverbase.h (serverframework\include):    struct TInternal* ix_;
Serverbase.h (serverframework\include):    typedef struct tagTimerInfo
Serverbase.h (serverframework\include):        struct timeval proctime_;//上次调用的时间
Service.cpp (serverframework\src\module):    base->log_.LOG_P_LEVEL(LOG_DEBUG, "spp_handle_input, %d, %d, %s\n", flow, blob->len, inet_ntoa(*(struct in_addr*)&extinfo->remoteip_));    
Service.cpp (serverframework\src\module):            pServerBase->log_.LOG_P_LEVEL(LOG_DEBUG,"Get client Remote ip = %s,port=%d\n",inet_ntoa(*((struct in_addr*)&extInfo->remoteip_)),extInfo->remoteport_);
Service.cpp (serverframework\src\module):extern "C" int spp_context_timeout_list(const std::vector<string> & v,void * arg1,void * arg2)
Service.cpp (serverframework\src\module):        string strKey = v[i];
Service.cpp (serverframework\src\module):        context = base->spp_get_context(strKey,true);
Shmcommu.cpp (serverframework\src\base):#include <string.h>
Shmcommu.cpp (serverframework\src\base):#define C_TM_PRIVATE_SIZE sizeof(struct timeval) //时间戳
Shmcommu.cpp (serverframework\src\base):    struct timeval tval;
Shmcommu.cpp (serverframework\src\base):    struct timeval time_stamp;
Shmcommu.cpp (serverframework\src\base):int CShmMQ::dequeue_i(void * arg1, unsigned int & flow, unsigned char & msgtype,struct timeval & time_stamp)
Shmcommu.cpp (serverframework\src\base):                pthread_mutexattr_destroy(&attr);
Shmcommu.cpp (serverframework\src\base):        pthread_mutex_destroy(mutex_); 
Shmcommu.cpp (serverframework\src\base):    struct sembuf op;
Shmcommu.cpp (serverframework\src\base):    struct sembuf op;
Shmcommu.cpp (serverframework\src\base):                pthread_mutexattr_destroy(&attr);
Shmcommu.cpp (serverframework\src\base):        pthread_mutex_destroy(mutex_); 
Shmcommu.cpp (serverframework\src\base):    struct sembuf op;
Shmcommu.cpp (serverframework\src\base):    struct sembuf op;
Shmcommu.cpp (serverframework\src\base):            struct tm tmm;
Shmcommu.h (serverframework\include):    struct semid_ds *buf;		//<= buffer for IPC_STAT & IPC_SET
Shmcommu.h (serverframework\include):    struct seminfo *__buf;		//<= buffer for IPC_INFO
Shmcommu.h (serverframework\include):typedef struct tagMQStat
Shmcommu.h (serverframework\include):    int dequeue_i(void* arg1, unsigned int & flow,unsigned char &msgtype,struct timeval & time_stamp);
Shmcommu.h (serverframework\include):typedef struct 
Shm_array.h (libcomm\include):    typedef struct data_item_t
Shm_array.h (libcomm\include):    typedef struct tagArrayHead
Shm_array.h (libcomm\include):struct RwlockHelper
Shm_array.h (libcomm\include):    typedef struct data_item_t
Shm_array.h (libcomm\include):    typedef struct tagArrayHead
Shm_array.h (libcomm\include):                pthread_rwlockattr_destroy(&rwlock_attr);
Shm_array.h (libcomm\include):#include <iostream.h>
Shm_array.h (libcomm\include):typedef struct tagItem
Shm_queue.h (libcomm\include):    typedef struct tagShmHead
Shm_queue.h (libcomm\include):#include <iostream>
Shm_queue.h (libcomm\include):typedef struct tagMsgInfo
Shm_stack.h (libcomm\include):    typedef struct tagShmHead
Sockcommu.cpp (serverframework\src\base):    printf("serv_type=%u,version=%s, route_str=%s,route_val=%d\n",serv_type_,version_.c_str(),route_.c_str(),route_val_);
Sockcommu.cpp (serverframework\src\base):struct CTSockCommu::TInternal
Sockcommu.h (serverframework\include):#include <string>
Sockcommu.h (serverframework\include):typedef struct 
Sockcommu.h (serverframework\include):typedef struct 
Sockcommu.h (serverframework\include):typedef struct tagTSockCommuConf
Sockcommu.h (serverframework\include):typedef struct
Sockcommu.h (serverframework\include):typedef struct tagTRouteTable
Sockcommu.h (serverframework\include):    string version_;//当前版本号
Sockcommu.h (serverframework\include):    string route_;//路由算法
Sockcommu.h (serverframework\include):typedef struct tagTRouteConfig
Sockcommu.h (serverframework\include):    struct TInternal;
Sockcommu.h (serverframework\include):    struct TInternal* ix_;	
Socket.cpp (serverframework\src\base):string CSocketAddr::in_n2s(ip_4byte_t addr)
Socket.cpp (serverframework\src\base):    char buf[INET_ADDRSTRLEN];
Socket.cpp (serverframework\src\base):    return p ? p : string();
Socket.cpp (serverframework\src\base):int CSocketAddr::in_s2n(const string& addr, ip_4byte_t& addr_4byte)
Socket.cpp (serverframework\src\base):    struct in_addr sinaddr;
Socket.cpp (serverframework\src\base):    int ret = inet_pton(AF_INET, addr.c_str(), &sinaddr);
Socket.cpp (serverframework\src\base):        fd =::socket(PF_INET, SOCK_STREAM, 0);
Socket.cpp (serverframework\src\base):        fd =::socket(PF_UNIX, SOCK_STREAM, 0);
Socket.cpp (serverframework\src\base):int CSocket::bind(int fd, const string &server_address, port_t port)
Socket.cpp (serverframework\src\base):int CSocket::bind(int fd, const string& path)
Socket.cpp (serverframework\src\base):    struct sockaddr_un addr;
Socket.cpp (serverframework\src\base):    bzero (&addr, sizeof (struct sockaddr_un));
Socket.cpp (serverframework\src\base):    strncpy(addr.sun_path, path.c_str(), path.length());
Socket.cpp (serverframework\src\base):    int ret = ::bind (fd, (struct sockaddr *)&addr, addrlen);
Socket.cpp (serverframework\src\base):int CSocket::connect(int fd, const string& address, port_t port)
Socket.cpp (serverframework\src\base):int CSocket::connect(int fd, const string& path)
Socket.cpp (serverframework\src\base):    struct sockaddr_un addr;
Socket.cpp (serverframework\src\base):    bzero (&addr, sizeof (struct sockaddr_un));
Socket.cpp (serverframework\src\base):    strncpy(addr.sun_path, path.c_str(), path.length());
Socket.cpp (serverframework\src\base):    int ret = ::connect(fd, (struct sockaddr*)&addr, addrlen);
Socket.cpp (serverframework\src\base):int CSocket::get_peer_name(int fd, string & peer_address, port_t & peer_port)
Socket.cpp (serverframework\src\base):int CSocket::get_sock_name(int fd, string & socket_address, port_t & socket_port)
Socket.cpp (serverframework\src\base):    struct timeval tv;
Socket.h (serverframework\include):#include <string>
Socket.h (serverframework\include):#include <string.h>
Socket.h (serverframework\include):    CSocketAddr():_len(sizeof(struct sockaddr_in))
Socket.h (serverframework\include):    {memset(&_addr, 0, sizeof(struct sockaddr_in));}
Socket.h (serverframework\include):    struct sockaddr * addr(){return (struct sockaddr *)(&_addr);}
Socket.h (serverframework\include):    struct sockaddr_in * addr_in(){return &_addr;}
Socket.h (serverframework\include):    static string in_n2s(ip_4byte_t addr);
Socket.h (serverframework\include):    static int in_s2n(const string& addr, ip_4byte_t& addr_4byte);
Socket.h (serverframework\include):    struct sockaddr_in _addr;
Socket.h (serverframework\include):    static int bind(int fd, const string& server_address, port_t port);
Socket.h (serverframework\include):    static int bind(int fd, const string& path);
Socket.h (serverframework\include):    static int connect(int fd, const string& addr, port_t port);
Socket.h (serverframework\include):    static int connect(int fd, const string& path);  	
Socket.h (serverframework\include):    static int get_peer_name(int fd, string& peer_address, port_t& peer_port);
Socket.h (serverframework\include):    static int get_sock_name(int fd, string& socket_address, port_t& socket_port);
Stat.cpp (serverframework\src\base):    strncpy(obj->id_, id, sizeof(obj->id_) - 1);    \
Stat.cpp (serverframework\src\base):        strncpy(obj->desc_, desc, sizeof(obj->desc_) - 1);  \
Stat.cpp (serverframework\src\base):typedef struct
Stat.cpp (serverframework\src\base):            if(!strcmp(obj->id_, ids[i]))
Stat.cpp (serverframework\src\base):            if(!strcmp(obj->id_, id) && ((type == STAT_TYPE_ALL) || (type == obj->type_)))
Stat.cpp (serverframework\src\base):    struct tm tmm;
Stat.cpp (serverframework\src\base):    struct tm tmm;
Stat.h (serverframework\include):#include <string.h>
Stat.h (serverframework\include):typedef struct
Stat.h (serverframework\include):typedef struct
Stat.h (serverframework\include):        int len = strlen(id);
Stat_policy.h (serverframework\include):typedef struct
SVShm.cpp (libcomm\src\shmhash):    return shmctl (this->internal_id_, cmd, (struct shmid_ds *) buf);
Tea.cpp (libcomm\src\util):        strcpy(src, argv[1]);
Tea.cpp (libcomm\src\util):        int srclen = strlen(src);
Util.cpp (libcomm\src\util):    struct stat s;
Util.cpp (libcomm\src\util):    struct stat s;
Util.cpp (libcomm\src\util):    std::string strDir;
Util.cpp (libcomm\src\util):        strDir.assign(pszName, p - pszName);
Util.cpp (libcomm\src\util):        if(false == IsDirExist(strDir.c_str()))
Util.cpp (libcomm\src\util):            if(-1 == mkdir(strDir.c_str(),mode))
Util.cpp (libcomm\src\util):char *strlower(char *s)
Util.cpp (libcomm\src\util):char *strupper(char *s)
Util.h (libcomm\include):#include <string>
Util.h (libcomm\include):char *strlower(char *s);
Util.h (libcomm\include):char *strupper(char *s);
